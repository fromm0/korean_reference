<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><title>prototype.js v1.5.0 사용하기</title>


	
		
		<meta content="tutorial, reference, documentation, prototype.js, prototype, ajax, JavaScript, web 2.0, using protoype.js, prototype-1.5.0.js, developer notes" name="KEYWORDS">
 		<meta name="description" content="Prototype.js documentation">
 		<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
		<link rel="stylesheet" href="prototype.js.en_files/prot_ref.css" type="text/css" media="all">
		<link rel="stylesheet" href="prototype.js.en_files/recommendations.css" type="text/css" media="all">
		
		<script type="text/javascript">
			//<![CDATA[
			/*
			function sp(link)
			{
				var em =  'serg' + 'io_p' + 'ereira@';
				em += 'ms' + 'n.c' + 'om';
				document.write('<a href="mai' + 'lto:' + em + '">' + link + '</a>');
			}
			*/

			function navigateToVersion(list)
			{
				var url = list.options[list.selectedIndex].value;
				if(url != '')
					document.location = url;
			}
			//	]]>
		</script>
	<link href="prototype.js.en_files/n2CoreLibs-n2v1-57871.css" type="text/css" rel="stylesheet"></head><body><div><div id="goPopElem" class="n2Pop" style="display: block; visibility: hidden; left: 0px; top: 0px; position: absolute;" onmouseover="goPop.mouseOver();" onmouseout="goPop.mouseOut(event);" onmousemove="goPop.mouseMove(event);" onmousedown="goPop._click(event);"><div class="n2"><div id="goPopElem_titleBar" class="popStaticTitle" style="visibility: inherit; min-height: 18px; height: 22px;"><div style="margin: 0px; padding: 2px 3px; float: right; background-color: rgb(239, 237, 212);" id="goPopElem_titleBarTd2"><span class="clickable" onclick="goPop.goBack()"><img style="display: none;" id="goPopElem_backBtn" class="clickable" src="prototype.js.en_files/back-tan-sm.gif" onmousedown="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/back-tan-sm-dn._V46913462_.gif';" onmouseup="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/back-tan-sm._V46922606_.gif';" border="0" height="16" width="46"></span><img style="display: none;" id="goPopElem_backBtnDis" class="clickable" src="prototype.js.en_files/back-tan-sm-dis.gif" border="0" height="16" width="46"><span class="clickable" onclick="goPop.goForward()"><img style="display: none;" id="goPopElem_nextBtn" class="clickable" src="prototype.js.en_files/next-tan-sm.gif" onmousedown="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/next-tan-sm-dn._V46686641_.gif';" onmouseup="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/next-tan-sm._V46865265_.gif';" border="0" height="16" width="46"></span><img style="display: none;" id="goPopElem_nextBtnDis" class="clickable" src="prototype.js.en_files/next-tan-sm-dis.gif" border="0" height="16" width="46"><span class="clickable" onclick="goPop.hide()"><img id="goPopElem_closeX" class="clickable" src="prototype.js.en_files/close-box-up.gif" onmousedown="this.src='http://g-images.amazon.com/images/G/01/nav2/images/close-box-down';" onmouseup="this.src='http://g-images.amazon.com/images/G/01/nav2/images/close-box-up';" border="0" height="15" width="15"></span></div><span style="display: block; padding-left: 0px; padding-top: 0px; background-color: rgb(239, 237, 212);" id="goPopElem_titleBarTitle" class="popTitle"></span></div><div id="goPopElem_main" class="n2PopBody" style="border-style: none solid solid; border-color: rgb(239, 237, 212); border-width: 5px; clear: both;">--CONTENT GOES HERE (static)--</div></div></div></div><a style="z-index: 225; display: none; position: absolute; background-color: transparent;" id="n2SPopClickGrab"></a><div><div id="goN2ExplorerDiv" class="n2Pop" style="display: block; visibility: hidden; left: 0px; top: 0px; position: absolute;" onmouseover="goN2Explorer.mouseOver();" onmouseout="goN2Explorer.mouseOut(event);" onmousemove="goN2Explorer.mouseMove(event);" onmousedown="goN2Explorer._click(event);"><div class="n2"><div id="goN2ExplorerDiv_titleBar" class="popStaticTitle" style="visibility: inherit; min-height: 18px;"><div style="padding: 3px 4px 0pt 0pt; float: right;" id="goN2ExplorerDiv_titleBarTd2"><span class="clickable" onclick="goN2Explorer.goBack()"><img style="display: none;" id="goN2ExplorerDiv_backBtn" class="clickable" src="prototype.js.en_files/back-tan-sm.gif" onmousedown="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/back-tan-sm-dn._V46913462_.gif';" onmouseup="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/back-tan-sm._V46922606_.gif';" border="0" height="16" width="46"></span><img style="display: none;" id="goN2ExplorerDiv_backBtnDis" class="clickable" src="prototype.js.en_files/back-tan-sm-dis.gif" border="0" height="16" width="46"><span class="clickable" onclick="goN2Explorer.goForward()"><img style="display: none;" id="goN2ExplorerDiv_nextBtn" class="clickable" src="prototype.js.en_files/next-tan-sm.gif" onmousedown="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/next-tan-sm-dn._V46686641_.gif';" onmouseup="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/next-tan-sm._V46865265_.gif';" border="0" height="16" width="46"></span><img style="display: none;" id="goN2ExplorerDiv_nextBtnDis" class="clickable" src="prototype.js.en_files/next-tan-sm-dis.gif" border="0" height="16" width="46"><span class="clickable" onclick="goN2Explorer.hide()"><img id="goN2ExplorerDiv_closeX" class="clickable" src="prototype.js.en_files/close-tan-sm.gif" onmousedown="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/close-tan-sm-dn._V46881222_.gif';" onmouseup="this.src='http://ec1.images-amazon.com/images/G/01/nav2/images/close-tan-sm._V46903531_.gif';" border="0" height="16" width="46"></span></div><span id="goN2ExplorerDiv_titleBarTitle" class="popTitle"></span></div><div id="goN2ExplorerDiv_main" class="n2PopBody" style="clear: both;">--CONTENT GOES HERE (static)--</div></div></div></div>
		<div id="mainContent">			
			<h1><a href="http://prototype.conio.net/">prototype.js</a>를 위한 개발자 노트</h1>
			<h2>1.5.0버전을 다룸</h2>
			
			<div class="author"><a href="mailto:sergio_pereira@msn.com">Sergio Pereira</a>에 의해 작성됨</div>
			<div class="author"><a href="mailto:fromm0@gmail.com">이동국</a>에 의해 번역됨</div>
			<div class="author">최근 업데이트: 2007년 3월 4일</div>
			<!-- 
			Translators: check out the file prot-changeLogs.html in this same directory
			for the diff files.
			-->
			<p id="versions">
				<select id="otherVersions" onchange="navigateToVersion(this)">
					<option value="" selected="selected">다른 버전</option>
					<option value="http://openframework.or.kr/framework_reference/prototype_js/1.5.0/prototype.js.html">Korean (v1.5.0)</option>
					<option value="http://openframework.or.kr/framework_reference/prototype_js/1.4.0/prototype.js.html">Korean (v1.4.0)</option>
					<option value="http://www.sergiopereira.com/articles/prototype.js.html">English (v1.5.0)</option>
					<option value="http://www.oreilly.com/catalog/prototypeqr/cover.html">PDF from O'Reilly</option>
					<option value="http://vnruby.org/repos/prototype.js.vi/prototype.js.vi.html">Vietnamese (v1.5.0)</option>
					<option value="http://www.bouwkamp.com/ajax/prototype.js.html">Dutch (v1.5.0)</option>
					<option value="http://www.imgsrc.co.jp/~kuriyama/prototype/prototype.js.html">Japanese (v1.5.0)</option>
					<option value="http://dcabasson.developpez.com/articles/javascript/ajax/documentation-prototype-1.4.0/">French (v1.4.0)</option>
					<option value="http://www.bilisim-kulubu.com/help/prototype.js.html">Turkish (v1.4.0)</option>	
					<option value="http://www.fabryprog.it/from_sergiopereira/prototype.js.html">Italian (v1.4.0)</option>
					<option value="http://www.sergiopereira.com/articles/prototype140.js.ptBR.html">Portuguese (v1.4.0)</option>
					<option value="http://thinhunan.cnblogs.com/archive/2006/04/01/DeveloperNotesForPrototype.html">Chinese (v1.4.0)</option>
					<option value="https://compdoc2cn.dev.java.net/prototype/html/prototype.js.cn.html">Chinese (v1.4.0)</option>	
					<option value="http://prototype.rajmi.hu/prototype.js.hu.html">Hungarian (v1.4.0)</option>
					<option value="http://www.bouwkamp.com/ajax/prototype140.js.html">Dutch (v1.4.0)</option>
					<option value="http://blog.elksoft.pl/wp-content/prototype.js.pl.html">Polish (v1.4.0)</option>
					<option value="http://www.sergiopereira.com/articles/prototype140.js.html">English (v1.4.0)</option>
					<option value="http://www.sergiopereira.com/articles/prototype131.js.html">English (v1.3.1)</option>
					<option value="http://www.electrolinux.com/traductions/prototype.js.html">French (v1.3.1)</option>	
					<option value="http://www.sergiopereira.com/articles/prototype.js.ro.html">Romanian (v1.3.1)</option>
					<option value="http://kropp.spb.ru/docs/prototype/">Russian (v1.3.1)</option>
					<option value="">Other versions (volunteers needed)</option>
				</select>
			</p>
<!-- ************************************************************************************************************************************* -->
			

			<h3 id="toc">목차</h3>
			<div>
				<ul>
					<li><a href="#Whatsthat">Prototype은 무엇인가.?</a></li>
					<li><a href="#RelatedArticle">관련글</a></li>
					<li><a href="#UtilityFunctions">utility 함수</a></li>
					<li><a href="#DollarFunction"><span class="functionName">$()</span> 함수 사용하기</a></li>
					<li><a href="#Dollar_Dollar_Function"><span class="functionName">$$()</span> 함수 사용하기</a></li>
					<li><a href="#Dollar_F_Function"><span class="functionName">$F()</span> 함수 사용하기</a></li>
					<li><a href="#Dollar_A_Function"><span class="functionName">$A()</span> 함수 사용하기</a></li>
					<li><a href="#Dollar_H_Function"><span class="functionName">$H()</span> 함수 사용하기</a></li>
					<li><a href="#Dollar_R_Function"><span class="functionName">$R()</span> 함수 사용하기</a></li>
					<li><a href="#TryThese"><span class="functionName">Try.these()</span> 함수 사용하기</a></li>
					<li><a href="#Strings">String을 향상시키기</a></li>
					<li><a href="#Strings.gsub">문자열 대체</a></li>
					<li><a href="#Strings.templates">문자열 템플릿</a></li>
					<li><a href="#UsingAjax"><span class="objectClass">Ajax</span> 객체</a></li>
					<li><a href="#UsingAjaxRequest"><span class="objectClass">Ajax.Request</span> class 사용하기</a></li>
					<li><a href="#UsingAjaxUpdater"><span class="objectClass">Ajax.Updater</span> class 사용하기</a></li>
					<li><a href="#Encoding">What are all those "?" and squares?</a></li>
					<li><a href="#Enumerating">열거(Enumerating)... </a></li>
					<li><a href="#Loops">루프, 루비-스타일</a></li>
					<li><a href="#EnumeratingArrays">스테로이드(steroids)에서 당신의 배열</a></li>
					<li><a href="#Books">내가 강력하게 추천하는 책들.</a></li>
					<li><a href="#Reference">prototype.js 참조</a></li>
					<li><a href="#Reference.Extensions">JavaScript classes를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.Object"><span class="code">Object</span> class를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.Number"><span class="code">Number</span> class를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.Function"><span class="code">Function</span> class를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.String"><span class="code">String</span> class를 위한 확장</a></li>
					<li><a href="#Reference.Array"><span class="code">Array</span> class를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.DOM"><span class="code">document</span> DOM 객체를 위한 확장</a></li>
					<li><a href="#Reference.Extensions.Event"><span class="code">Event</span> 객체를 위한 확장</a></li>
					<li><a href="#Reference.NewObjects">prototype.js에 새롭게 정의된 객체와 클래스</a></li>
					<li><a href="#Reference.PeriodicalExecuter"><span class="objectClass">PeriodicalExecuter</span> 객체</a></li>
					<li><a href="#Reference.Prototype"><span class="objectClass">Prototype</span> 객체</a></li>
					<li><a href="#Reference.Enumerable"><span class="objectClass">Enumerable</span> 객체</a></li>
					<li><a href="#Reference.Hash"><span class="objectClass">Hash</span> 객체</a></li>
					<li><a href="#Reference.ObjectRange"><span class="objectClass">ObjectRange</span> class</a></li>
					<li><a href="#Reference.Class"><span class="objectClass">Class</span> 객체</a></li>
					<li><a href="#Reference.Ajax"><span class="objectClass">Ajax</span> 객체</a></li>
					<li><a href="#Ajax.Responders"><span class="objectClass">Ajax.Responders</span> 객체</a></li>
					<li><a href="#Ajax.Base"><span class="objectClass">Ajax.Base</span> class</a></li>
					<li><a href="#Ajax.Request"><span class="objectClass">Ajax.Request</span> class</a></li>
					<li><a href="#Ajax.options"><span class="objectClass">options</span> 인자 객체</a></li>
					<li><a href="#Ajax.Updater"><span class="objectClass">Ajax.Updater</span> class</a></li>
					<li><a href="#Ajax.PeriodicalUpdater"><span class="objectClass">Ajax.PeriodicalUpdater</span> class</a></li>
					<li><a href="#Element"><span class="objectClass">Element</span> 객체</a></li>
					<li><a href="#Element.ClassNames"><span class="objectClass">Element.ClassNames</span> class</a></li>
					<li><a href="#Abstract"><span class="objectClass">Abstract</span> 객체</a></li>
					<li><a href="#Abstract.Insertion"><span class="objectClass">Abstract.Insertion</span> class</a></li>
					<li><a href="#Insertion"><span class="objectClass">Insertion</span> 객체</a></li>
					<li><a href="#Insertion.Before"><span class="objectClass">Insertion.Before</span> class</a></li>
					<li><a href="#Insertion.Top"><span class="objectClass">Insertion.Top</span> class</a></li>
					<li><a href="#Insertion.Bottom"><span class="objectClass">Insertion.Bottom</span> class</a></li>
					<li><a href="#Insertion.After"><span class="objectClass">Insertion.After</span> class</a></li>
					<li><a href="#Field"><span class="objectClass">Field</span> 객체</a></li>
					<li><a href="#Form"><span class="objectClass">Form</span> 객체</a></li>
					<li><a href="#Form.Element"><span class="objectClass">Form.Element</span> 객체</a></li>
					<li><a href="#Form.Element.Serializers"><span class="objectClass">Form.Element.Serializers</span> 객체</a></li>
					<li><a href="#Abstract.TimedObserver"><span class="objectClass">Abstract.TimedObserver</span> class</a></li>
					<li><a href="#Form.Element.Observer"><span class="objectClass">Form.Element.Observer</span> class</a></li>
					<li><a href="#Form.Observer"><span class="objectClass">Form.Observer</span> class</a></li>
					<li><a href="#Abstract.EventObserver"><span class="objectClass">Abstract.EventObserver</span> class</a></li>
					<li><a href="#Form.Element.EventObserver"><span class="objectClass">Form.Element.EventObserver</span> class</a></li>
					<li><a href="#Form.EventObserver"><span class="objectClass">Form.EventObserver</span> class</a></li>
					<li><a href="#Position"><span class="objectClass">Position</span> 객체 (사전 준비중인 문서)</a></li>
				</ul>
			</div>
<!-- ************************************************************************************************************************************* -->

			<h3 id="Whatsthat">Prototype은 무엇인가.?</h3>
			<p>
				<a href="http://prototype.conio.net/">prototype.js</a>는 <a href="http://www.conio.net/">Sam Stephenson</a>에 의해 작성된 자바스크립트 라이브러리이다. 이 놀랍도록 멋진 생각과 <strong>표준에 의해</strong> 잘 작성된 코드의 일부는 웹2.0의 특성을 나타내는 풍부하고 상호작용하는 웹페이지와 많은 연관을 가진다.
			</p>
			<p>
				만약 당신이 최근 이 라이브러리를 사용하기 시작했다면, 당신은 아마도 이 문서가 가장 좋은 지시사항중에 하나는 아니라는것을 알아차렸을것이다. 나 이전에 다른 많은 개발자들처럼, 나는 소스코드와 이것을 사용한 경험에서 prototype.js에 대한 지식을 가지게 되었다. 나는 모든 이가 배우고 공유하는 동안 좀더 많은 정보를 얻게 되는게 가장 좋은 것이라고 생각한다.
			</p>
			<p>
				나는 objects, classes, functions, 그리고 이 라이브러리에 의해 제공되는 확장을 위한 <a href="#Reference">비공식적인 참조문서</a> 또한 제공한다.
			</p>
			<p>
				당신이 예제와 참조문서를 읽었을때, Ruby프로그래밍 언어에 친숙한 개발자는 Ruby의 내장 클래스와 이 라이브러리에 의해 구현된 많은 확장 사이의 의도적인 유사성을 알아차리게 될것이다.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>


			<h3 id="RelatedArticle">관련글</h3>
			<p>
				고급 <a href="http://openframework.or.kr/framework_reference/prototype_js/Quick_guide_to_somewhat_advanced_JavaScript.html">자바스크립트 가이드</a>
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ************************************************************************************************************************************* -->

			<h3 id="UtilityFunctions">유틸리티 함수들</h3>
			<p>
				라이브러리는 미리 정의된 많은 수의 객체와 유틸리티 함수를 가진다. 이 알기쉬운 함수들의 목적은 반복적인 타이핑과 어구를 많이 줄이는데 있다.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="DollarFunction"><span class="functionName">$()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$()</span>함수는 가장 많이 사용되는 DOM의 <span class="code">document.getElementById()</span>함수에 대한 편리한 단축키이다. DOM함수처럼, 이것은 인자로 던져진 id를 가진 요소를 하나 반환한다. 
			</p>
			<p>
				DOM함수와는 달리 이 함수는 더 많은 작업을 수행한다. 반환된 element객체는 몇가지 추가적인 작업을 하게 될것이다. element를 숨기거나 보여주고 크기를 알아내며 element에 대해 스크롤을 하는 것과 같은 추가적인 많은 작업을 간단하게 만든다. <a href="#Reference.Element" class="code">Element</a> 객체를 위한 참조문서에서 반환된 element객체에 추가된 메소드 목록을 얻을수 있다. 
			</p>
			<pre class="code"><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt; Test Page &lt;/title&gt;
<strong class="highlite">&lt;script src="prototype.js"&gt;&lt;/script&gt;</strong>

&lt;script&gt;
	function test(){
		<strong class="highlite">var d = $('myDiv');</strong>
		alert(d.innerHTML);
		d.<strong class="highlite">hide</strong>();
		d.<strong class="highlite">show</strong>();
		d.<strong class="highlite">addClassName</strong>('active');
	}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
	&lt;div id="myDiv"&gt;
		&lt;p&gt;This is a paragraph&lt;/p&gt;
	&lt;/div&gt;
	&lt;div id="myOtherDiv"&gt;
		&lt;p&gt;This is another paragraph&lt;/p&gt;
	&lt;/div&gt;

	&lt;input type="button" value="Test $()" onclick="test();"/&gt;&lt;br/&gt; 

&lt;/body&gt;
&lt;/html&gt;</code></pre>			

			<p>
				이 함수의 좋은 점은 이것은 인자형태를 가질수 있는 다른 함수를 생성할때 매우 유용하도록 만들어주는 id문자열이나 요소객체 자체를 던질수 있다는 것이다. 
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			

			<h4 id="Dollar_Dollar_Function"><span class="functionName">$$()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$$()</span> 함수는 내용물에서 CSS를 일관되게 분리할때 많이 도와줄것이다. 하나 이상의 CSS필터링 표현식을 파싱한다면, CSS 룰을 정의하기 위해 사용되는 것과 유사하고 이러한 필터에 일치하는 요소를 반환한다. 
			</p>
			<p>
				이 함수는 터무니 없을 정도로 사용하기가 쉽다. 체크해보라. 
			</p>
			<pre class="code"><code>&lt;script&gt;
function test$$(){
	/*
	  in case CSS is not your forte, the expression below says
	  'find all the INPUT elements that are inside 
	  elements with class=field that are inside a DIV
	  with id equal to loginForm.'
	*/
	var f = $$('div#loginForm .field input');
	var s = '';
	for(var i=0; i&lt;f.length; i++){
		s += f[i].value + '/';
	}
	alert(s); // shows: "joedoe1/secret/"
	
	//now passing more than one expression
	f = $$('div#loginForm .field input', 'div#loginForm .fieldName');
	s = '';
	for(var i=0; i&lt;f.length; i++){
		s += ( f[i].value ? f[i].value : f[i].innerHTML ) + '/';
	}
	alert(s); //shows: "joedoe1/secret/User name:/Password:/"
}


&lt;/script&gt;

&lt;div id='loginForm'&gt;
	&lt;div class='field'&gt;
		&lt;span class='fieldName'&gt;User name:&lt;/span&gt;
		&lt;input type='text' id='txtName' value='joedoe1'/&gt;
	&lt;/div&gt;
	&lt;div class='field'&gt;
		&lt;span class='fieldName'&gt;Password:&lt;/span&gt;
		&lt;input type='password' id='txtPass' value='secret' /&gt;
	&lt;/div&gt;
	&lt;input type='submit' value='login' /&gt;
&lt;/div&gt; 
&lt;input type=button value='test $$()' onclick='test$$();' /&gt;
			</code></pre>

			<p>
				성능에 대한 빠른 노트. prototype.js에서 $$() 함수의 현재 구현체는 특별히 효과적으로 여겨지지 않는다. 이 함수를 자주 사용하여 복잡한 HTML문서를 처리하고자 계힉중이라면, 가능한 $$()함수 자체를 대체하는 다른 구현체를 고려하고자 할것이다. 
			</p>
			
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			

			<h4 id="Dollar_F_Function"><span class="functionName">$F()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$F()</span> 함수는 다른 단축키이다. 이것은 텍스트 박스나 드랍다운 리스트와 같은 어떤 필드의 입력 컨트롤의 값을 반환한다. 이 함수는 요소 id나 요소객체 자체를 인자로 가질수 있다.
			</p>
			<pre class="code"><code>&lt;script&gt;
	function test3()
	{
		alert(  <strong class="highlite">$F('userName')</strong>  );
	}
&lt;/script&gt;

&lt;input type="text" id="userName" value="Joe Doe"&gt;&lt;br/&gt; 
&lt;input type="button" value="Test3" onclick="test3();"&gt;&lt;br/&gt; 
			</code></pre>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			

			<h4 id="Dollar_A_Function"><span class="functionName">$A()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$A()</span> 함수는 이것을 받아들이는 하나의 인자를 <span class="code">Array</span>객체로 변환한다.
			</p>
			<p>
				<a href="#Reference.Array">Array 클래스를 위한 확장</a>과 조합된 이 함수는 열거가능한 리스트를 <span class="code">Array</span> 객체로 변환하거나 복사하는 것을 더욱 쉽게 만든다. 예를 들면, 작성한 함수는 인자의 수를 유연하게 받아들인다. 여기서 추천되는 사용법은 DOM 
				<span class="code">NodeLists</span>를 좀더 효과적으로 처리할수 있도록 일반적인 배열로 변환하기 위해 사용하는 것이다. 아래의 예제를 보라.
			</p>
			<pre class="code"><code>&lt;script&gt;

	function showOptions(){
		var someNodeList = $('lstEmployees').getElementsByTagName('option');
		var nodes = $A(someNodeList);

		nodes.each(function(node){
				alert(node.nodeName + ': ' + node.innerHTML);
			});
	}
&lt;/script&gt;

&lt;select id="lstEmployees" size="10" &gt;
	&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
	&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
	&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;

&lt;input type="button" value="Show the options" onclick="showOptions();" &gt; 
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			
			
			<h4 id="Dollar_H_Function"><span class="functionName">$H()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$H()</span> 함수는 객체를 결합된 배열을 열거하는 <a href="#Reference.Hash">Hash</a>객체로 변환한다. 
			</p>
			<pre class="code"><code>&lt;script&gt;
	function testHash()
	{
		//let's create the object
		var a = {
			first: 10,
			second: 20,
			third: 30
			};

		//now transform it into a hash
		var h = <strong class="highlite">$H(a)</strong>;
		alert(h.toQueryString()); //displays: first=10&amp;second=20&amp;third=30
	}

&lt;/script&gt;
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			
			
			<h4 id="Dollar_R_Function"><span class="functionName">$R()</span> 함수 사용하기</h4>
			<p>
				<span class="code">$R()</span> 함수는 <span class="code">new ObjectRange(lowerBound, upperBound, excludeBounds)</span>를 작성하기 위한 짧은 형태이다.
			</p>
			<p>
				이 클래스의 완전한  설명을 보기 위해 <a href="#Reference.ObjectRange">ObjectRange</a> 클래스 문서를 보라. <span class="code">each</span> 메소드를 통해 반복(iterators)의 사용법을 보여주는 간단한 예제를 보자. 더 많은 메소드는 <a href="#Reference.Enumerable">Enumerable</a> 클래스 문서에서 볼수 있을것이다.
			</p>
			<pre class="code"><code>&lt;script&gt;
	function demoDollar_R(){
		var range = <strong class="highlite">$R(10, 20, false)</strong>;
		range.each(function(value, index){
			alert(value);
		});
	}

&lt;/script&gt;

&lt;input type="button" value="Sample Count" onclick="demoDollar_R();" /&gt; 
			</code></pre>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			
			
			<h4 id="TryThese"><span class="functionName">Try.these()</span> 함수 사용하기</h4>
			<p>
				<span class="code">Try.these()</span> 함수는 인자처럼 많은 수의 함수를 가지고 그것들을 순서대로 차례차례 호출하도록 해준다. 이것은 함수중에 하나씩 수행하고 성공적인 함수호출의 결과를 반환할때까지 순차적으로 수행된다.
			</p>
			<p>
				아래의 예제에서 <span class="code">xmlNode.text</span> 함수는 몇몇 브라우저에서 작동하고 <span class="code">xmlNode.textContent</span>는 다른 브라우저에서 작동한다. <span class="code">Try.these()</span>함수를 사용하면 당신은 작동하는 것 중 하나를 반환할수 있다.
			</p>
			<pre class="code"><code>&lt;script&gt;
function getXmlNodeValue(xmlNode){
	return <strong class="highlite">Try.these</strong>(
		function() {return xmlNode.text;},
		function() {return xmlNode.textContent;}
		);
}
&lt;/script&gt;
			</code></pre>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ************************************************************************************************************************************* -->
			<h3 id="Strings">String을 향상시키기</h3>
			<p>
				String은 강력한 객체이다. Prototype.js는 그 강력함을 가지고 있으며 다른 방법으로 그 강력함을 향상시킨다. 
			</p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			
			
			<h4 id="Strings.gsub">문자열 대체</h4>
			<p>
				문자열 대체를 사용할때 자바스크립트는 이미 <span class="code">String.Replace</span>와 같은 메소드를 제공하고 있다. 정규표현식으로 작동하지만 prototype.js에서 소개한 대체 함수만큼 유연하지는 않다. 
			</p>
			<p>
				새로운 <span class="code">String.gsub</span> 메소드를 사용해보라. 이 메소드를 사용하면 고정 문자열이나 정규 표현식 패턴을 찾고 변경할수 있을 뿐 아니라 교체를 넘어서는 더 많은 제어를 하게 된다. 예를 들어 찾은 요소를 변형하고자 하는 방법을 메소드에 지시하도록 문자열 템플릿을 사용할수 있다. 
			</p>
			<p>
				아래의 예제는 't'를 포함하는 단어를 찾고 그 위치에 'tizzle' 로 변경하는 것이다. 이 예제의 경우 명확하게 설명되지는 않는다. 우리가 선택한 정규 표현식인 괄호안의 <strong>\w+</strong>은 그룹 선언을 가져온다. 대체 템플릿 문자열로 <strong>#{1}</strong>를 사용하여 이 그룹에 의해 해당되는 값을 가져올수 있다. 
			</p>
			<p>
				예제에서 우리는 't'앞의 문자들을 가져와서 'tizzle'를 뒤에 붙인다. 정규 표현식으로 더 많은 찾을 수 있다면, <strong>#{2}</strong>, <strong>#{3}</strong> 등등을 사용하여 값을 가져올것이다. 
			</p>
			<pre class="code"><code>&lt;script&gt;
function talkLikeYouKnowSomething(){
	var s = 'prototype string extensions can help you';
	var snoopdogfy = /\b(\w+)t\w+\b/;
	var snooptalk = s.<strong class="highlite">gsub</strong>(snoopdogfy, '#{1}tizzle' );
	alert(snooptalk); // shows: "prototizzle stizzle extizzle can help you"				
}
&lt;/script&gt;
			</code></pre>
			<p>
				여기서 멈추지 말자. 우리가 만든 대체기능은 패턴에 일치하면 대체하는데 제한되기 때문에 그다지 강력하다고 보기 힘들다. 그렇다면 원하는 대체 값을 만들기 위해 사용자 정의 로직에 일치하는 작업을 할수 있을까.? <span class="code">gsub</span>에 두번째 인자로 함수를 넘길수 있다면 그렇게 할수 있을것이다. 여기서 인자로 넘기는 함수는 일치하는 텍스트를 가진 배열(인덱스값이 0)을 받고 어떤 그룹값(인덱스값이 1에서 N)을 가져올것이다. 
			</p>
			
			<pre class="code"><code>&lt;script&gt;
function scamCustomers(){
	var prices = 'book1 $12.5, magazine $5.50, pencil $1.20';
	var priceFinder = /\$([0-9\.]+)/;
	var r = prices.gsub(priceFinder, <strong class="highlite">jackUp</strong>);
	alert(r);//shows: "book1 $13.75, magazine $6.05, pencil $1.32"
}
<strong class="highlite">	
function jackUp(matches){
	//increases the prices by 10%
	var price = parseFloat(matches[1]);
   	return '$' + Math.round(110 * price)/100;
}</strong>
&lt;/script&gt;
			</code></pre>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			
			<h4 id="Strings.templates">문자열 템플릿</h4>
			<p>
				애플리케이션에 자바스크립트 코드의 양이 증가하는 만큼, 
				increasingly you'll find yourself with collections of objects of 
				the same type and that you need to list or present in a formatted way.
			</p>
			<p>
				애플리케이션에서 객체 리스트를 통해 루프를 처리하고 객체 프라퍼티와 몇가지 고정된 형태의 요소에 기초하여 문자열을 만드는 코드를 찾는것이 드물게 발생하지는 않는다. Prototype.js는 이러한 타입의 시나리오를 다루는데 도움을 주는 <a href="#Reference.Template">Template class</a>를 가진다. 
			</p>
			<p>
				아래의 예제는 다중 HTML라인에서 장바구니에 있는 항목 리스트를 형상화하는 방법을 보여준다. 
			</p>
			<pre class="code"><code>&lt;script&gt;
function printCart(){
	//creating a sample cart
	var cart = new Object();
	cart.items = [ ];
	//putting some sample items in the cart
	cart.items.push({product: 'Book 123', price: 24.50, quantity: 1});
	cart.items.push({product: 'Set of Pens', price: 5.44, quantity: 3});
	cart.items.push({product: 'Gift Card', price: 10.00, quantity: 4});
	
	//here we create our template for formatting each item
	var itemFormat = <strong class="highlite">new Template(
			'You are ordering #{quantity} units ' + 
			'of #{product} at $#{price} each'
			);</strong>
	var formatted = '';
	
	for(var i=0; i&lt;cart.items.length; i++){
		var cartItem = cart.items[i];
		formatted += itemFormat.<strong class="highlite">evaluate</strong>(cartItem) + '&lt;br/&gt;\n';
	}
	
	alert(formatted);
	/* SHOWS:
	You are ordering 1 units of Book 123 at $24.5 each&lt;br/&gt;
	You are ordering 3 units of Set of Pens at $5.44 each&lt;br/&gt;
	You are ordering 4 units of Gift Card at $10 each&lt;br/&gt;
	*/
}
&lt;/script&gt;
			</code></pre>
			
			<p>
				새로운 메소드 목록에 대한 좀더 완전한 정보를 보기 위해서는 <a href="#Reference.Extensions.String">문자열 확장</a>  참조를 보라. 
			</p>
			
			<p class="backToc"><a href="#toc">toc</a></p>
		
			
<!-- ************************************************************************************************************************************* -->
			
			<h3 id="UsingAjax"><span class="objectClass">Ajax</span> 객체</h3>
			<p>
				위에서 언급된 유틸리티 함수들은 좋다. 하지만 다시 보자. 그것들은 대부분 고급(advanced) 형태는 아니다. 당신은 스스로 이것들을 만들수 있고 당신 자신만의 스크립트에 유사한 함수를 이미 가지고 있을수도 있다. 하지만 이러한 함수들은 단지 일부분에 해당되는 팁일뿐이다.</p>
			<p>
				나는 prototype.js에 대한 당신의 관심이 대부분의 <a href="http://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX</a>기능을 다룰수 있다는 것이라고 확신한다. 그래서 당신이 AJAX로직을 수행할 필요가 있을때 좀더 쉽게 사용하도록 도와주는 라이브러리를 사용하는 방법을 살펴보자.
			</p>
			<p>
				<span class="code">AJAX</span>객체는 AJAX함수를 작성할 때 포함되는 트릭성격의 코드를 포장하고 단순화하기 위한 라이브러리에 의해 생성된 미리-정의된 객체이다. 이 객체는 캡슐화된 AJAX로직을 제공하는 많은 수의 클래스를 포함한다. 그 클래스중에 몇개를 살펴보자.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->			

			<h4 id="UsingAjaxRequest"><span class="objectClass">Ajax.Request</span> 클래스 사용하기</h4>
			<p>
				만약 당신이 어떠한 헬퍼(helper) 라이브러리도 사용하지 않는다면, 당신은 <span class="code">XMLHttpRequest</span>객체를 생성하기 위한 많은 코드를 작성할 것이고 단계를 비동기적으로 수행할것이다. 그리고나서 응답을 뽑아내고 이것을 처리한다. 그리고나서는 한가지 이상의 브라우저를 지원하지 않는다면 스스로 행운이라고 생각할 것이다.
			</p>
			
			<p>
				AJAX기능을 지원하기 위해, 라이브러리는 <span class="code">Ajax.Request</span>클래스를 정의한다.
			</p>
			<p>
				당신이 다음처럼 XML응답을 반환하는 <em>http://yourserver/app/get_sales?empID=1234&amp;year=1998</em> url을 통해 서버와 통신할수 있는 애플리케이션을 가지고 있다고 해보자.
			</p>
			
			<pre class="code"><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
&lt;ajax-response&gt;
	&lt;response type="object" id="productDetails"&gt;
		&lt;monthly-sales&gt;
			&lt;employee-sales&gt;
				&lt;employee-id&gt;1234&lt;/employee-id&gt; 
				&lt;year-month&gt;1998-01&lt;/year-month&gt; 
				&lt;sales&gt;$8,115.36&lt;/sales&gt; 
			&lt;/employee-sales&gt;
			&lt;employee-sales&gt;
				&lt;employee-id&gt;1234&lt;/employee-id&gt; 
				&lt;year-month&gt;1998-02&lt;/year-month&gt; 
				&lt;sales&gt;$11,147.51&lt;/sales&gt; 
			&lt;/employee-sales&gt;
		&lt;/monthly-sales&gt;
	&lt;/response&gt;
&lt;/ajax-response&gt;			
			</code></pre>
			
			<p>
				XML을 가져오기 위해 서버와 통신하는 것은 <span class="code">Ajax.Request</span>객체를 사용하면 매우 간단하다. 아래의 샘플은 이것을 수행하는 방법을 보여준다.
			</p>
			
			<pre class="code"><code>&lt;script&gt;
	function searchSales()
	{
		var empID = $F('lstEmployees');
		var y = $F('lstYears');
		var url = 'http://yourserver/app/get_sales';
		var pars = 'empID=' + empID + '&amp;year=' + y;
		<strong class="highlite">
		var myAjax = new Ajax.Request(
			url, 
			{
				method: 'get', 
				parameters: pars, 
				onComplete: showResponse
			});
		</strong>
	}

	function showResponse(originalRequest)
	{
		//put returned XML in the textarea
		$('result').value = originalRequest.responseText;
	}
&lt;/script&gt;

&lt;select id="lstEmployees" size="10" onchange="searchSales()"&gt;
	&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
	&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
	&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;
&lt;select id="lstYears" size="3" onchange="searchSales()"&gt;
	&lt;option selected="selected" value="1996"&gt;1996&lt;/option&gt;
	&lt;option value="1997"&gt;1997&lt;/option&gt;
	&lt;option value="1998"&gt;1998&lt;/option&gt;
&lt;/select&gt;
&lt;br/&gt;&lt;textarea id="result" cols=60 rows=10 &gt;&lt;/textarea&gt;
			</code></pre>
		
			<p>
				<span class="code">Ajax.Request</span>객체 생성자의 두번째 파라미터를 알아보겠는가.? <span class="code">{method: 'get', parameters: pars, onComplete: showResponse}</span> 파라미터는 문자적 표기법으로 익명 객체를 나타낸다. 이것이 의미하는 것은 <span class="code">'get'</span> 문자열을 포함하는 명명된 <span class="code">메소드(method)</span>의 프라퍼티, HTTP요청 문자열을 포함하는 명명된 <span class="code">파라미터(parameter)</span>라는 프라퍼티, 그리고 함수 <span class="code">showResponse</span>를 포함하는 <span class="code">onComplete</span> 프라퍼티/메소드를 가지는 객체를 전달한다는 것이다.
			</p>
			<p>
				당신이 AJAX를 <span class="code">비동기적으로(asynchronous)</span> 서버에 호출할지를 결정하고 <span class="code">true</span>나 <span class="code">false</span>값으로 셋팅할수 있는 asynchronous(디폴트 값은 <span class="code">true</span>이다.)와 같은 이 객체내 정의하고 활성화시킬수 있는 다른 프라퍼티가 몇개 있다.
			</p>
			<p>
				이 파라미터는 AJAX호출을 위한 옵션을 정의한다. 샘플에서, 우리는 HTTP GET명령을 통해 첫번째 인자에서 url을 호출한다. 변수 <span class="code">pars</span>내 포함된 조회문자열(querystring)을 전달하고 <span class="code">Ajax.Request</span>객체는 응답을 받아들이는 작업을 마칠때 <span class="code">showResponse</span>함수를 호출할 것이다.
			</p>
			<p>
				당신이 아는것처럼, <span class="code">XMLHttpRequest</span>는 HTTP호출을 하는 동안 진행과정을 보고한다. 이 진행과정은 4가지의 단계(<em>Loading</em>, <em>Loaded</em>, <em>Interactive</em>, 또는 <em>Complete</em>)를 알릴수 있다. 당신은 이러한 단계중에서 <span class="code">Ajax.Request</span>객체 호출을 사용자정의 함수로 만들수 있다. Complete는 가장 공통적인 단계이다. 함수를 객체에게 알리기 위해, 우리 예제의 <span class="code">onComplete</span>처럼 요청옵션내 <span class="code">onXXXXX</span>로 명명된 프라퍼티/메소드를 간단히 제공하라. 당신이 전달하는 이 함수는 <span class="code">XMLHttpRequest</span>객체 자체가 될 하나의 인자를 가진 객체에 의해 호출될것이다. 당신은 반환 데이터를 얻기 위해 이 객체를 사용할수 있고 아마도 호출의 HTTP결과 코드를 포함할 <span class="code">상태(status)</span> 프라퍼티를 체크할것이다. 몇가지 스크립트나 JSON형태의 데이터를 반환하고자 한다면 X-JSON 헤더가 유용하다. 
			</p>	
			<p>
				두개의 다른 흥미로운 옵션은 결과를 처리하기 위해 사용될수 있다. 우리는 AJAX호출이 에러없이 수행될때 호출될 함수처럼 <span class="code">onSuccess</span>옵션을 명시할수 있다. <span class="code">onFailure</span>옵션은 서버에러가 발생할때 호출될 함수가 될수 있다. <span class="code">onXXXXX</span>의 선택적인 함수처럼, 이 두가지는 AJAX호출을 옮기고 X-JSON헤더를 체크하는 <span class="code">XMLHttpRequest</span>를 전달하도록 호출될 것이다. 
			</p>
			<p>
				우리의 샘플은 흥미로운 방법으로 XML응답을 처리하지는 않았다. 우리는 textarea내 XML을 집어넣었다. 응답의 전형적인 사용법은 XML내부에서 바라는 정보를 찾고자 할것이고 몇몇 페이지 요소나 페이지내 HTML을 만드는 몇가지의 XSLT변형을 업데이트할것이다. 
			</p>
			<p>
				1.4.0 버전에서, 이벤트 콜랙 핸들링의 새로운 형태가 소개되었다. 만약 당신이 AJAX호출이 발생하는데도 불구하고 특정 이벤트를 위해 수행되어야 하는 코드를 가지고 있다면, 당신은 새로운 <a href="#Ajax.Responders">Ajax.Responders</a> 객체를 사용할수 있다.
			</p>
			<p>
				당신이 AJAX호출이 진행중이라는 시각적 표시를 보여주길 원한다고 해보자. 당신은 두개의 전역 이벤트 핸들러를 사용할수 있다. 하나는 첫번째 호출이 시작되었을때 아이콘을 보여주는것이고 다른 하나는 적어도 하나가 끝났을때 아이콘을 숨기는 것이다. 아래의 예제를 보자.
			</p>
		
			<pre class="code"><code>&lt;script&gt;
	var myGlobalHandlers = {
		onCreate: function(){
			Element.show('systemWorking');
		},

		onComplete: function() {
			if(Ajax.activeRequestCount == 0){
				Element.hide('systemWorking');
			}
		}
	};

	<strong class="highlite">Ajax.Responders.register(myGlobalHandlers);</strong>
&lt;/script&gt;

&lt;div id='systemWorking'&gt;&lt;img src='spinner.gif'&gt;Loading...&lt;/div&gt;
	</code></pre>
			<p>
				좀더 완전한 설명을 보기 위해서, <a href="#Ajax.Request">Ajax.Request 참조</a> 와 <a href="#Ajax.options">options 참조</a>를 보라..
			</p>

			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="UsingAjaxUpdater"><span class="objectClass">Ajax.Updater</span> 클래스 사용하기</h4>
			<p>
				만약 당신이 HTML로 이미 포맷팅된 정보를 반환할수 있는 서버 종료점(endpoint)을 가진다면, 라이브러리는 당신이 <span class="code">Ajax.Updater</span>클래스를 사용하는것을 좀더 쉽게 만들어준다. 이것으로 당신은 어느 요소가 AJAX호출로부터 반환된 HTML을 채우는지 알리게 된다. 예제는 내가 글로 표현하는 것보다 당신을 좀더 쉽게 이해하도록 도와줄것이다.
			</p>

		
			<pre class="code"><code>&lt;script&gt;
	function getHTML()
	{
		var url = 'http://yourserver/app/getSomeHTML';
		var pars = 'someParameter=ABC';
		<strong class="highlite">
		var myAjax = new Ajax.Updater(
			'placeholder', 
			url, 
			{
				method: 'get', 
				parameters: pars
			});
		</strong>
	}
&lt;/script&gt;

&lt;input type="button" value="GetHtml" onclick="getHTML()"/&gt;
&lt;div id="placeholder"&gt;&lt;/div&gt;
			</code></pre>
			
			<p>
				당신이 보는것처럼, 코드는 <span class="code">onComplete</span>함수와 생성자에 전달된 요소 id를 제외하고 이전예제에 비해서 매우 간단하다. 클라이언트에서 서버 에러들을 다루는 것이 어떻게 가능한지 보기 위해 코드를 조금 변경해 보자.
			</p>
			<p>
				우리는 호출을 위해 더 많은 옵션을 추가하고 에러 상황을 뽑아내기 위해 함수를 명시한다. 이것은 <span class="code">onFailure</span>옵션을 사용하여 수행한다. 우리는 성공적인 작동의 경우에만 활성화될 <span class="code">묶음자(placeholder)</span>를 명시할것이다. 이것을 달성하기 위해, 우리는 간단한 요소 id에서 두개의 프라퍼티(<span class="code">success</span>-모든것이 정상적일때 사용되는, <span class="code">failure</span>-어떤것이 실패일때 사용되는)를 가지는 객체로 첫번째 파라미터를 변경할 것이다. 우리는 예제에서 <span class="code">failure</span> 프라퍼티를 사용하지 않을것이고, <span class="code">onFailure</span>옵션에서 <span class="code">reportError</span>함수를 사용할것이다.
			</p>
			<pre class="code"><code>&lt;script&gt;
	function getHTML()
	{
		var url = 'http://yourserver/app/getSomeHTML';
		var pars = 'someParameter=ABC';
		<strong class="highlite">
		var myAjax = new Ajax.Updater(
					{success: 'placeholder'}, 
					url, 
					{
						method: 'get', 
						parameters: pars, 
						onFailure: reportError
					});
		</strong>
	}

	function reportError(request)
	{
		alert('Sorry. There was an error.');
	}
&lt;/script&gt;

&lt;input type="button" value="GetHtml" onclick="getHTML()"/&gt;
&lt;div id="placeholder"&gt;&lt;/div&gt;

			</code></pre>
			<p>
				만약 당신의 서버 로직이 HTML마크업 대신에 자바스크립트 코드를 반환한다면, <span class="code">Ajax.Updater</span>객체는 자바스크립트 코드가 될수 있다. 자바스크립트로 응답을 처리하기 위한 객체를 얻기 위해, 당신은 객체 생성자의 마지막 인자로 프라퍼티들의 목록에 <span class="code">evalScripts: true;</span>를 간단히 추가한다. 하지만 여기엔 문제가 있다. 이러한 스크립트 블럭은 페이지의 스크립트에 추가되지 않을것이다. 옵션이름인 <span class="code">evalScripts</span>이 제시하는것처럼, 스크립트는  <strong>평가</strong>될것이다. 차이점이 무엇일까.? 요청된 URL이 반환하는 것이 무엇인지 추측해보자.
			</p>
			<pre class="code"><code>&lt;script language="javascript" type="text/javascript"&gt;
	function sayHi(){
		alert('Hi');
	}
&lt;/script&gt;

&lt;input type="button" value="Click Me" onclick="sayHi()"/&gt;
			</code></pre>
			<p>
				이 경우 당신이 이전에 이것을 시도했다면 이것이 작동하지 않는것을 알고 있을것이다. 이유는 스크립트 블럭은 평가될것이고 평가된 스크립트는 <span class="code">sayHi</span> 라는 이름의 함수를 생성하지 않을것이다. 이것은 아무것도 하지 않을것이다. 이 함수를 생성하기 위해, 우리는 함수를 <strong>생성</strong>하기 위해 변경할 필요가 있다. 아래를 보라.
			</p>
			<pre class="code"><code>&lt;script language="javascript" type="text/javascript"&gt;
	<strong class="highlite">sayHi = function(){
		alert('Hi');
	};</strong>
&lt;/script&gt;

&lt;input type="button" value="Click Me" onclick="sayHi()"/&gt;
			</code></pre>
			<p>
				이전 예제에서, 우리는 변수를 선언하기 위해 <span class="code">var</span> 키워드를 사용하지 않았다. 그렇게 하는 것은 스크립트 블럭에 지역화될 함수 객체를 생성할것이다. <span class="code">var</span> 키워드 없이 함수 객체는 window범위에서 작동한다. 
			</p>
			<p>
				좀더 상세한 complete설명을 위해서는, <a href="#Ajax.Updater">Ajax.Updater 참조문서</a>와 <a href="#Ajax.options">options 참조문서</a>를 보라.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h3 id="Encoding">What are all those "?" and squares?</h3>
			<p>
				So you went and wrote some quick test scripts to update your pages using the 
				<span class="code">Ajax.Updater</span> object and it all worked fine. Life was good until 
				you ran your scripts against real data. All of a sudden the updated text was displayed 
				with question marks or unprintable character symbols where the non-English characters 
				should be.
			</p>
			<p>
				Your first suspect is prototype.js, Of course, it seemed too easy to be true. 
				But don't blame the library just yet. Ask yourself how much you really understand
				character encoding, code pages, and how the browser deals with it. If you have a 
				positive answer then I bet you are on your way to fix the problem. If you are 
				among the other 80% (another useless, imprecise author's estimate) of web developers 
				that take character encoding for granted, keep reading.
			</p>
			<p>
				I won't pretend to be an authority on the topic, much less give you a complete explanation 
				of how this is best handled. Instead you go straight to the solution that I use and provide 
				hints on how this could be fixed in your own scenario.
			</p>
			<p>
				Simply put, the solution revolves around the following statement: Serve what the browser is 
				expecting you to serve. If we are going to update the page with text that contains Unicode/UTF-8 
				characters then we better make the browser aware of that. 
			</p>
			<p>
				Let's start with the simple case when you are just updating the page with text from a static HTML 
				file that resides on your server. When you created that file, depending on which text editor you 
				employed, it is very possible that the file was saved in ANSI (or better said, non-Unicode) format. 
				This is the default for many text editors, especially source code editors, because the file size 
				will be smaller and it's rather unusual to edit source code with Unicode characters in it. 
			</p>
			<p>
				Suppose you have the following file named static-content.html on your server. You saved this file 
				saved in ANSI format.
			</p>
			
			<pre class="code"><code>&lt;div&gt;
	Hi there, José. Yo no hablo español.
&lt;/div&gt;</code></pre>
			
			<p>
				Your main page updates itself using something like the snippet below.
			</p>

			<pre class="code"><code>&lt;script&gt;
	function updateWithFile(){
		var url = 'static-content.html';
		var pars = '';
		var myAjax = new Ajax.Updater(
				'placeholder', url, 
				{method: 'get', parameters: pars});
	}
&lt;/script&gt;
&lt;div id="placeholder"&gt;(this will be replaced)&lt;/div&gt;
&lt;input id="btn" value="Test With Static File" 
                 onclick="updateWithFile()" type="button"/&gt;

</code></pre>

			<p>
				When you click the button the static file is retrieved but the non-English characters are 
				replaced by question marks or some other symbol. The displayed text will look similar to 
				<i>"Hi there, Jos?. Yo no hablo espa?ol."</i> or <i>"Hi there, Jos?Yo no hablo espa?"</i>, 
				depending on your browser.
			</p>
			<p>
				In this case, the solution is straightforward, simply save the static file in an appropriate 
				format. Let's save it in UTF-8 and run the script again (any decent text editor will have an 
				option in the Save As dialog.) You should now see the correct text (if not, your browser 
				may have cached the old version, try using a different file name.)
			</p>
			<p>
				If the HTML that you are serving is not static, if it is being dynamically generated by some 
				application framework (like ASP.NET, PHP, or even Perl,) make sure the code that generates this
				HTML is producing the text in the appropriate encoding and code page, and include in the HTTP 
				response headers one header that informs this. Each platform has a different way to achieve 
				this, but they are very similar.
			</p>
			<p>
				For example, in ASP.NET you can set this globally in your web.config file and the default 
				configuration is good enough to avoid this problem in the first place. You should already 
				have the following section in your web.config. 
			</p>

			<pre class="code"><code>&lt;globalization requestEncoding="utf-8" responseEncoding="utf-8" /&gt;</code></pre>

			<p>
				고전적인 ASP 3.0에서 다음의 코드를 사용하여 이 문제를 해결할수 있다. 
			</p>

			<pre class="code"><code>Response.CodePage = 65001
Response.CharSet = "utf-8" </code></pre>

			<p>
				PHP에서 응답 헤더를 추가하기 위한 문법은 다음과 같을것이다. 
			</p>

			<pre class="code"><code>&lt;?php header('Content-Type: text/html; charset=utf-8'); ?&gt;</code></pre>

			<p>
				어떤 경우에는, 당신이 생각하는 목표가 응답 메시지에 다음 HTTP 헤더를 보내는 것이다. 
			</p>

			<pre class="code"><code>Content-Type: text/html; charset=utf-8 </code></pre>

			<p>
				위 예제에서는 UTF-8을 사용했지만 다른 셋팅이 필요하다면 쉽게 바꿀수 있다. 
			</p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h3 id="Enumerating">열거(Enumerating)... </h3>
			<p>
				우리는 루프(loop)에 친숙하다. 당신이 알다시피, 배열 자체를 생성하고 같은 종류의 요소로 채운다. 루프 제어구조(이를 테면, foreach, while, repeat 등등)을 생성하고 숫자로 된 인덱스를 통해 순차적으로 각각의 요소에 접근하고 그 요소로 작업을 수행한다. 
			</p>
			<p>
				당신이 이것에 대해 생각할때, 언제나 당신은 코드에 배열을 가지고 루프내 배열을 사용할것이라는것을 의미한다. 이러한 반복을 다루기 위해 좀더 많은 기능을 가진 배열 객체가 있다면 좋지 않겠는가.? 그렇다. 많은 프로그래밍 언어는 배열이나 유사한 구조(collection과 list와 같은)에서 이러한 기능을 제공한다. 
			</p>
			<p>
				prototype.js는 우리에게 반복가능한 데이터를 다룰때 사용하도록 구현된 <a href="#Reference.Enumerable" class="code">Enumerable</a> 객체를 제공한다. prototype.js 라이브러리는 더 나아가 <span class="code">Enumerable</span>의 모든 메소드로 <a href="#Reference.Array"><span class="code">Array</span> 클래스를 확장한다</a>
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>


			<h4 id="Loops">루프, 루비-스타일</h4>
			<p>
				표준 자바스크립트에서, 당신이 배열의 요소를 순차적으로 표시하길 원한다면, 당신은 다음처럼 작성할수 있다. 
			</p>
			<pre class="code"><code>&lt;script&gt;
	function showList(){
		var simpsons = ['Homer', 'Marge', 'Lisa', 'Bart', 'Maggie'];
<strong class="highlite">		for(i=0;i&lt;simpsons.length;i++){
			alert(simpsons[i]);
		}</strong>
	}

&lt;/script&gt;

&lt;input type="button" value="Show List" onclick="showList();" /&gt; 
			</code></pre>
			<p>
				prototype.js를 사용하면, 다음과 같이 다시 작성할수 있다. 
			</p>
			<pre class="code"><code>
	function showList(){
		var simpsons = ['Homer', 'Marge', 'Lisa', 'Bart', 'Maggie'];
<strong class="highlite">		simpsons.each( function(familyMember){
			alert(familyMember);
		});</strong>
	}
			</code></pre>
			<p>
				당신은 특이한 문법으로 별로 좋지않다고 생각할지도 모른다. 위 예제에서, 엉망으로 만드는 것은 아무것도 없다. After all, there's not much to be changed in such a drop-dead-simple example. But keep reading, nonetheless.
			</p>
			<p>
				<span class="code">each</span> 메소드에 대한 인자처럼 전달되는 이 함수는 보았는가.? <strong>iterator</strong> 함수처럼 이것을 참조해보자. 
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>


			<h4 id="EnumeratingArrays">스테로이드(steroids)에서 당신의 배열</h4>
			<p>
				위에서 언급된것처럼, 이것은 같은 프라퍼티와 메소드를 가지는 배열내 모든 요소를 위해 공통이다. 우리의 새로운 배열을 가지고 iterator함수의 장점을 가질수 있는 방법을 보자. 
			</p>
			<p>
				문법에 따르는 요소를 찾아라. 
			</p>
			<pre class="code"><code>&lt;script&gt;
	function findEmployeeById(emp_id){
		var listBox = $('lstEmployees')
		var options = listBox.getElementsByTagName('option');
		options = $A(options);
		var opt = options.<strong class="highlite">find</strong>( <strong>function(employee){
			return </strong><strong class="highlite">(employee.value == emp_id)</strong><strong>;
		}</strong>);
		alert(opt.innerHTML); //displays the employee name
	}
&lt;/script&gt;

&lt;select id="lstEmployees" size="10" &gt;
	&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
	&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
	&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;

&lt;input type="button" value="Find Laura" onclick="findEmployeeById(8);" /&gt; 
			</code></pre>
			<p>
				배열에서 항목을 걸러내는 방법을 보자. 그리고나서 각각의 요소로부터 맴버를 가져온다. 
			</p>
			<pre class="code"><code>&lt;script&gt;
	function showLocalLinks(paragraph){
		paragraph = $(paragraph);
		var links = $A(paragraph.getElementsByTagName('a'));
		//find links that do not start with 'http'
		var localLinks = links.<strong class="highlite">findAll</strong>( function(link){
			//we'll just assume for now that external links
			// do not have a '#' in their url
			return link.href.indexOf('#') &gt;= 0;
		});
		//now the link texts
		var texts = localLinks.<strong class="highlite">pluck('innerHTML')</strong>;
		//get them in a single string
		var result = texts.<strong class="highlite">inspect()</strong>;
		alert(result);
	}

&lt;/script&gt;
&lt;p id="someText"&gt;
	This &lt;a href="http://othersite.com/page.html"&gt;text&lt;/a&gt; has 
	a &lt;a href="#localAnchor"&gt;lot&lt;/a&gt; of 
	&lt;a href="#otherAnchor"&gt;links&lt;/a&gt;. Some are 
	&lt;a href="http://wherever.com/page.html"&gt;external&lt;/a&gt;
	and some are &lt;a href="#someAnchor"&gt;local&lt;/a&gt;
&lt;/p&gt;
&lt;input type="button" value="Find Local Links" onclick="showLocalLinks('someText')"/&gt;
			</code></pre>
			<p>
				이것은 이 문법에 완전히 빠지도록 하기 위한 몇가지 예제를 가진다. 사용가능한 모든 함수를 위해 <a href="#Reference.Enumerable" class="code">Enumerable</a>
				and <a href="#Reference.Array" class="code">Array</a> 참조문서를 보라.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ************************************************************************************************************************************* -->
			

			<!-- Translators: please ignore and remove this book reference stuff -->
			<h3 id="Books">내가 강력하게 추천하는 책들.</h3>
			<p>
				다음의 책들은 AJAX애플리케이션을 만들기 위해 요구되는 새로운 스킬을 배우는데 많은 도움을 주었고 이미 알고 있던 스킬을 좀더 탄탄하게 만들어주었다. 나는 좋은 책이 충분히 금적적인 가치를 하고 오랜시간동안 가치를 이어간다고 생각한다. 
			</p>

			<p class="recommendations" id="books">
				<a name="evtst|a|0764579088" href="http://www.amazon.com/dp/0764579088?tag=sergiopereira-20&amp;link_code=as3&amp;creativeASIN=0764579088&amp;creative=373489&amp;camp=211189"><img alt="" src="prototype.js.en_files/0764579088.jpg"></a><img alt="" src="prototype.js.en_files/ir_004.gif" class="tracker">

				<a name="evtst|a|1932394613" href="http://www.amazon.com/dp/1932394613?tag=sergiopereira-20&amp;link_code=as3&amp;creativeASIN=1932394613&amp;creative=373489&amp;camp=211189"><img alt="" src="prototype.js.en_files/1932394613.jpg"></a><img alt="" src="prototype.js.en_files/ir_007.gif" class="tracker">

				<a name="evtst|a|0321385551" href="http://www.amazon.com/dp/0321385551?tag=sergiopereira-20&amp;link_code=as3&amp;creativeASIN=0321385551&amp;creative=373489&amp;camp=211189"><img alt="" src="prototype.js.en_files/0321385551.jpg"></a><img alt="" src="prototype.js.en_files/ir.gif" class="tracker">

				<a name="evtst|a|0321237706" href="http://www.amazon.com/dp/0321237706?tag=sergiopereira-20&amp;link_code=as3&amp;creativeASIN=0321237706&amp;creative=373489&amp;camp=211189"><img alt="" src="prototype.js.en_files/0321237706.jpg"></a><img alt="" src="prototype.js.en_files/ir_005.gif" class="tracker">

				<a name="evtst|a|0974514055" href="http://www.amazon.com/dp/0974514055?tag=sergiopereira-20&amp;link_code=as3&amp;creativeASIN=0974514055&amp;creative=373489&amp;camp=211189"><img alt="" src="prototype.js.en_files/0974514055.jpg"></a><img alt="" src="prototype.js.en_files/ir_002.gif" class="tracker">

				
<img src="prototype.js.en_files/ir_006.gif"><img src="prototype.js.en_files/ir_003.gif">
			</p>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ************************************************************************************************************************************* -->
			

			<h3 id="Reference">prototype.js 참조</h3>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Extensions">JavaScript 클래스에 대한 확장</h4>
			<p>
				prototype.js라이브러리에 기능을 추가하기 위한 방법중 하나는 현재 존재하는 JavaScript클래스를 확장하는 것이다.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Extensions.Object"><span class="code">Object</span> 클래스를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
			        <col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Extensions.Object.extend">
						<td>extend(destination, source)</td><td>static</td><td>destination: 객체, source: 객체</td>
						<td class="refDescription"><span class="code">source</span>에서 <span class="code">destination</span>으로 모든 프라퍼티와 메소드를 복사하여 상속을 구현하기 위한 방법을 제공</td>
					</tr>
					<tr id="Reference.Extensions.Object.inspect">
						<td>inspect(targetObj)</td><td>static</td><td>targetObj: 객체</td>
						<td class="refDescription">targetObj의 사람이 읽을수 있는 문자열 표현으로 반환. 주어진 객체가 <span class="code">inspect</span> 인스턴스 메소드를 정의하지 않는다면, <span class="code">toString</span> 의 값을 반환</td>
					</tr>
					<tr id="Reference.Extensions.Object.keys">
						<td>keys(targetObj)</td><td>static</td><td>targetObj: 객체</td>
						<td class="refDescription">모든 프라퍼티의 이름과 주어진 객체의 메소드를 가진 <span class="code">Array</span>를 반환</td>
					</tr>
					<tr id="Reference.Extensions.Object.values">
						<td>values(targetObj)</td><td>static</td><td>targetObj: 객체</td>
						<td class="refDescription">모든 프라퍼티의 값과 주어진 객체의 메소드를 가진 <span class="code">Array</span>를 반환</td>
					</tr>
					<tr id="Reference.Extensions.Object.clone">
						<td>clone(targetObj)</td><td>static</td><td>targetObj: 객체</td>
						<td class="refDescription">targetObj의 얕은(shallow) 복사물을 반환</td>
					</tr>

				</tbody></table>
			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
			
			<h4 id="Reference.Extensions.Number"><span class="code">Number</span> 클래스를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Extensions.Object.toColorPart">
						<td>toColorPart()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">
						숫자의 16진법 표현을 반환. 색상의 RGB컴포넌트를 HTML표현으로 변환할때 유용</td>
					</tr>
					<tr id="Reference.Extensions.Object.succ">
						<td>succ()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">다음 숫자를 반환. 이 함수는 반복을 포함하는 시나리오에서 사용된다. 
						</td>
					</tr>
					<tr id="Reference.Extensions.Object.times">
						<td>times(iterator)</td><td>instance</td><td>iterator: Function(value, index)를 충족하는 함수 객체</td> 
						<td class="refDescription">인자 <span class="code">value</span>와 <span class="code">index</span>를 반복적으로 전달하는 <span class="code">iterator</span> 함수를 호출하는 것은 iteration과 현재 index내 현재 값을 각각 포함한다.  
						</td>
					</tr>
				</tbody></table>
			<p>
				다음의 예제는 0에서 9까지의 메시지 박스를 표시할것이다.
			</p>
			<pre class="code"><code>&lt;script&gt;
	function demoTimes(){
		var n = 10;
		n.times(function(index){
			alert(index);
		});
		/***************************
		 * you could have also used: 
		 *           (10).times( .... ); 
		 ***************************/
	}

&lt;/script&gt;

&lt;input type="button" value="Test Number.times()" onclick="demoTimes()"/&gt;
			</code></pre>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Extensions.Function"><span class="code">Function</span> 클래스를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Extensions.Function.bind">
						<td>bind(object [, arg1 [, arg2 [...]]])</td><td>instance</td><td>object: 메소드를 소유하는 객체</td>
						<td class="refDescription">함수(=메소드) 소유자 객체로 미리 묶는 함수의 인스턴스를 반환. 반환된 함수는 원래의 것과 같은 인자를 가질것이다.</td>
					</tr>
					<tr id="Reference.Extensions.Function.bindAsEventListener">
						<td>bindAsEventListener(object [, arg1 [, arg2 [...]]])</td><td>instance</td><td>object: 메소드를 소유하는 객체</td>
						<td class="refDescription">유하는 객체	함수(=메소드) 소유자 객체로 미리 묶는 함수의 인스턴스를 반환. 반환된 함수는 이것의 인자로 현재 <span class="code">이벤트</span> 객체를 가질것이다.</td>
					</tr>
				</tbody></table>
			<p>
				실제로 이 확장 중 하나를 보자.
			</p>
			<pre class="code"><code>&lt;input type="checkbox" id="myChk" value="1"/&gt; Test?
&lt;script&gt;
	//declaring the class
	var CheckboxWatcher = Class.create();

	//defining the rest of the class implementation
	CheckboxWatcher.prototype = {

	   initialize: function(chkBox, message) {
			this.chkBox = $(chkBox);
			this.message = message;
			//assigning our method to the event
			<strong class="highlite">
			this.chkBox.onclick = 
			   this.showMessage.bindAsEventListener(this, ' from checkbox');
			</strong>
	   },

	   showMessage: function(evt, extraInfo) {
		  alert(this.message + ' (' + evt.type + ')' + extraInfo);
	   }
	};


	var watcher = new CheckboxWatcher('myChk', 'Changed');
&lt;/script&gt;

			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Extensions.String"><span class="code">String</span> 클래스를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>


					<tr id="Reference.Extensions.String.camelize">
						<td>camelize()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">-(하이픈)으로 분리된 문자열을 camelCaseString으로 변환하기. 이 함수는 예를 들면, 프라퍼티 스타일을 다루는 코드를 작성할때 유용하다.</td>
					</tr>
					<tr id="Reference.Extensions.String.capitalize">
						<td>capitalize()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">첫번째 글자를 대문자로 변환</td>
					</tr>
					<tr id="Reference.Extensions.String.dasherize">
						<td>dasherize()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">'_' 기호를 '-' 기호로 대체</td>
					</tr>
					<tr id="Reference.Extensions.String.escapeHTML">
						<td>escapeHTML()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">HTML마크업 문자들이 escaped된 문자열 반환</td>
					</tr>
					<tr id="Reference.Extensions.String.evalScripts">
						<td>evalScripts()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">문자열내에서 발견되는 각각의 <span class="code">&lt;script /&gt;</span>블럭을 평가하기</td>
					</tr>
					<tr id="Reference.Extensions.String.extractScripts">
						<td>extractScripts()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">문자열내에서 발견되는 모든 <span class="code">&lt;script /&gt;</span>블럭을 포함하는 <span class="code">Array</span>객체 반환</td>
					</tr>
					<tr id="Reference.Extensions.String.gsub">
						<td>gsub(pattern, replacement)</td><td>instance</td>
						<td>
							pattern: 검색하는 문자열이나 정규 표현식
							replacement: 간단한 문자열, 템플릿 문자열 또는 대체물을 만들기 위한 Function(strings[]) 
						</td>
						<td class="refDescription">
							현재 문자열에서 패턴 문자열을 찾은 결과의 문자열을 반환하고 대체 문자열이나 패턴에 일치하는 문자열을 가진 배열을 전달하는 대체함수를 호출한 결과로 대체한다. 대체물이 문자열일때, #{n}과 같은 특별한 템플릿 형태의 토큰을 포함할수 있다. 여기서 n이라는 값은 정규표현식 그룹의 인덱스이다. #{0}는 완전히 일치하면 대체될것이고 #{1}는 첫번째 그룹, #{2}는 두번째이다. 
						</td>
					</tr>
					<tr id="Reference.Extensions.String.parseQuery">
						<td>parseQuery()</td><td>instance</td><td>(none)</td>
						<td class="refDescription"><span class="code">toQueryParams()</span>와 같음.</td>
					</tr>
					<tr id="Reference.Extensions.String.scan">
						<td>scan(pattern, replacement)</td><td>instance</td>
						<td>
							pattern: 검색하는 문자열이나 정규 표현식.
							replacement: 반복을 통해 일치하는지 보는 Function(strings[])
						</td>
						<td class="refDescription">
							반복을 통해 문자열이 일치하는 패턴을 찾기 위한 방법을 제공한다. pattern인자는 문자열이나 RegExp가 될수 있지만 RegExp는 좀더 유용하다. 유사하게도 replacement인자는 문자열이나 함수가 될수 있지만 유용한것을 만들수 있도록 함수에 전달하는것이 좋다. 
						</td>
					</tr>					
					<tr id="Reference.Extensions.String.strip">
						<td>strip()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">문자열의 앞뒤로 공백 없는 문자열을 반환</td>
					</tr>					
					<tr id="Reference.Extensions.String.stripScripts">
						<td>stripScripts()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">삭제된 <span class="code">&lt;script /&gt;</span> 블럭을 가진 문자열을 반환</td>
					</tr>
					<tr id="Reference.Extensions.String.stripTags">
						<td>stripTags()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">HTML이나 XML태그가 삭제된 문자열을 반환</td>
					</tr>
					<tr id="Reference.Extensions.String.sub">
						<td>sub(pattern, replacement [, count])</td><td>instance</td>
						<td>
							pattern: 검색하는 문자열이나 정규 표현식.
							replacement: 문자열 또는 대체물을 만드는 Function(strings[]) 
							count: 숫자나 대체물 - 디폴트는 1
						</td>
						<td class="refDescription">
							<a class="code" href="#Reference.Extensions.String.gsub">gsub</a>와 매우 유사하지만 count파라미터로 지정되는 대체물의 수에 제한이 있다 
						</td>
					</tr>					
					<tr id="Reference.Extensions.String.toArray">
						<td>toArray()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">문자열을 이것의 문자들의 <span class="code">Array</span>로 쪼개기</td>
					</tr>
					<tr id="Reference.Extensions.String.toQueryParams">
						<td>toQueryParams()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">쿼리문자열(querystring)을 파라미터 이름에 의해 인덱스화되는 결합된 <span class="code">Array</span>로 쪼개기</td>
					</tr>
					<tr id="Reference.Extensions.String.truncate">
						<td>truncate(length [, truncation])</td><td>instance</td>
						<td>
							length: 결과 문자열의 최대 길이
							truncation: 결과 문자열의 마지막 글자를 대체하기 위해 사용되는 문자열 - 디폴트는 '...'
						</td>
						<td class="refDescription">
							최대 길이의 문자열을 만들기 위해 사용. 문자열이 최대 길이를 유지하기 위해 짤릴필요가 있을 경우, truncation인자의 텍스트는 마지막의 몇개의 글자를 대체하기 위해 사용된다. 
							(이를테면.: <span class="code">var s='123456790'; alert(s.truncate(5)); //displays '12...'</span> )
						</td>
					</tr>					
					<tr id="Reference.Extensions.String.underscore">
						<td>underscore()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">
							CamelizedStringValue를 uderscore_formatted_string로 변환.
							(이를테면.: <span class="code">var s='Namespace::MyClass123'; alert(s.underscore()); 
							//displays 'namespace/my_class123'</span> ).
							이 함수는 루비 온 레일즈 기능에서 직접 대상이 될것처럼 보인다. 
						</td>
					</tr>
					<tr id="Reference.Extensions.String.unescapeHTML">
						<td>unescapeHTML()</td><td>instance</td><td>(none)</td>
						<td class="refDescription"><span class="code">escapeHTML()</span>의 반대</td>
					</tr>
				</tbody></table>


			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Array"><span class="code">Array</span> 클래스를 위한 확장</h4>
			<p>
				시작하기 위해, <span class="code">Array</span>는 <span class="code">Enumerable</span>를 확장한다. 그래서 <span class="code">Enumerable</span>객체내에 정의되는 모든 편리한 메소드는 사용가능하다. 이것외에도, 아래의 메소드들이 구현되었다.
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Array.clear">
						<td>clear()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">배열을 비우고 자체를 반환한다.</td>
					</tr>
					<tr id="Reference.Array.compact">
						<td>compact()</td><td>instance</td><td>(none)</td>
						<td class="refDescription"><span class="code">null</span> 이거나 <span class="code">undefined</span>인 요소를 제외하고 배열을 반환한다. 이 메소드는 배열자체를 변경하지 않는다.</td>
					</tr>
					<tr id="Reference.Array.first">
						<td>first()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">배열의 첫번째 요소를 반환한다.</td>
					</tr>
					<tr id="Reference.Array.flatten">
						<td>flatten()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">기복이 없고, 1차원의 배열을 반환한다. 이 함수는 배열이고 반환된 배열내 요소를 포함하는 배열의 각 요소를 찾음으로써 수행된다.</td>
					</tr>
					<tr id="Reference.Array.indexOf">
						<td>indexOf(value)</td><td>instance</td>
						<td>value: what you are looking for.</td>
						<td class="refDescription">배열에서 찾아진다면 주어진 <span class="code">value</span>의 0부터 시작하는 인덱스의 위치를 반환. <span class="code">value</span>이 없다면 -1을 반환	</td>
					</tr>
					<tr id="Reference.Array.inspect">
						<td>inspect()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">요소를 가진 배열의 잘 포맷팅된 문자열 표시를 반환하기 위해 변경</td>
					</tr>
					<tr id="Reference.Array.last">
						<td>last()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">배열의 마지막 요소를 반환한다.</td>
					</tr>
					<tr id="Reference.Array.reverse">
						<td>reverse([applyToSelf])</td><td>instance</td>
						<td>applyToSelf: 배열 자체가 반전되는지 표시</td>
						<td class="refDescription">역순서로 배열을 반환. 인자가 주어지지 않거나 인자가 <span class="code">true</span>라면, 배열자체는 반전될것이다. 그렇지 않으면 변경되지 않고 남는다.</td>
					</tr>
					<tr id="Reference.Array.shift">
						<td>shift()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">첫번째 요소를 반환하고 배열로부터 이것을 제거한다. 배열의 길이는 1 감소한다.</td>
					</tr>
					<tr id="Reference.Array.without">
						<td>without(value1 [, value2 [, .. valueN]])</td><td>instance</td>
						<td>value1 ... valueN: 배열내 존재한다면 제외될 값</td>
						<td class="refDescription">인자의 리스트에 포함된 요소를 제외한 배열을 반환. 이 메소드는 배열 자체를 변경하지는 않는다. </td>
					</tr>
				</tbody></table>
			<p>
				이 메소드들을 사용하는 것을 보자.
			</p>
			<pre class="code"><code>&lt;script&gt;
var A = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
alert(A.inspect()); // "['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"
var B = A.<strong class="highlite">without('e','f')</strong>;
alert(B.inspect()); // "['a', 'b', 'c', 'd', 'g', 'h']"
alert(A.inspect()); // did not change A: "['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"
A.push(null);
A.push('x');
A.push(null);
A.push('y');
alert(A.inspect()); // "['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', null, 'x', null, 'y']"
A = A.<strong class="highlite">compact()</strong>;
alert(A.inspect()); // "['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'x', 'y']"
var e = A.<strong class="highlite">shift()</strong>;
alert(e); // "a" 
alert(A.inspect()); // "['b', 'c', 'd', 'e', 'f', 'g', 'h', 'x', 'y']"
alert(A.<strong class="highlite">indexOf('c')</strong>); // 1
alert(A.<strong class="highlite">first()</strong>); // 'b'
alert(A.<strong class="highlite">last()</strong>); // 'y'
A.<strong class="highlite">clear()</strong>;
alert(A.inspect()); // "[]"
A = ['a', 'b', 'c'];
B = A.<strong class="highlite">reverse(false)</strong>;
alert(B.inspect()); // "['c', 'b', 'a']"
alert(A.inspect()); // A left untouched: "['a', 'b', 'c']"
A.<strong class="highlite">reverse(true)</strong>;
alert(A.inspect()); // "['c', 'b', 'a']"	
A = ['a', 'b',  ['c1','c2','c3'] , 'd',  ['e1','e2']  ];
B = A.<strong class="highlite">flatten()</strong>;
alert(B.inspect()); // "['a','b','c1','c2','c3','d','e1','e2']"		
alert(A.inspect()); // unchanged: "['a','b',['c1','c2','c3'],'d',['e1','e2']]"		
&lt;/script&gt;
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
			
			<h4 id="Reference.Extensions.DOM"><span class="code">document</span> DOM 객체를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Array.getElementsByClassName">
						<td>getElementsByClassName(className [, parentElement])</td><td>instance</td>
						<td>className: 요소와 연관된 CSS 클래스 이름, 
						parentElement: 객체 또는 가져올 요소를 포함하는 요소의 객체나 id</td>
						<td class="refDescription">주어진 CSS 클래스명과 연관된 모든 요소를 반환. <span class="code">parentElement</span> id가 주어졌다면, 전체 문서가 검색될것이다.
						</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
			
			<h4 id="Reference.Extensions.Event"><span class="code">Event</span> 객체를 위한 확장</h4>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>상세설명</th>
					</tr>
					<tr>
						<td>KEY_BACKSPACE</td><td>Number</td>
						<td class="refDescription">8: 되돌리기(<-) 키를 위한 상수 코드.</td>
					</tr>
					<tr>
						<td>KEY_TAB</td><td>Number</td>
						<td class="refDescription">9: 탭키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_RETURN</td><td>Number</td>
						<td class="refDescription">13: 리턴키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_ESC</td><td>Number</td>
						<td class="refDescription">27: Esc키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_LEFT</td><td>Number</td>
						<td class="refDescription">37: 왼쪽 화살표 키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_UP</td><td>Number</td>
						<td class="refDescription">38: 위쪽 화살표 키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_RIGHT</td><td>Number</td>
						<td class="refDescription">39: 오른쪽 화살표 키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_DOWN</td><td>Number</td>
						<td class="refDescription">40: 아래쪽 화살표 키를 위한 상수코드</td>
					</tr>
					<tr>
						<td>KEY_DELETE</td><td>Number</td>
						<td class="refDescription">46: Delete키를 위한 상수코드</td>
					</tr>
					<tr class="privateMember">
						<td>observers:</td><td>Array</td>
						<td class="refDescription">캐시된 관찰자(observers)의 목록. 상세한 객체의 내부구현의 일부</td>
					</tr>
				</tbody></table>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Event.element">
						<td>element(event)</td><td>static</td>
						<td>event: Event객체</td>
						<td class="refDescription">이벤트를 일으키는 요소를 반환</td>
					</tr>
					<tr id="Reference.Array.isLeftClick">
						<td>isLeftClick(event)</td><td>static</td>
						<td>event: Event객체</td>
						<td class="refDescription">마우스 왼쪽 버튼을 클릭시 <span class="code">true</span>값 반환</td>
					</tr>
					<tr id="Reference.Event.pointerX">
						<td>pointerX(event)</td><td>static</td>
						<td>event: Event객체</td>
						<td class="refDescription">페이지에서 마우스 포인터의 x측 좌표값 반환</td>
					</tr>
					<tr id="Reference.Event.pointerY">
						<td>pointerY(event)</td><td>static</td>
						<td>event: Event객체</td>
						<td class="refDescription">페이지에서 마우스 포인터의 y측 좌표값 반환</td>
					</tr>
					<tr id="Reference.Event.stop">
						<td>stop(event)</td><td>static</td>
						<td>event: Event객체</td>
						<td class="refDescription">이벤트의 디폴트 행위를 취소하고 위임을 연기하기 위해 이 함수를 사용</td>
					</tr>
					<tr id="Reference.Event.findElement">
						<td>findElement(event, tagName)</td><td>static</td>
						<td>event: Event객체, tagName: 원하는 태그명</td>
						<td class="refDescription">DOM트리 위쪽으로 가로지른다. 주어진 태그명을 가진 첫번째 요소를 검색한다. 이벤트를 발생시키는 요소로부터 시작한다.</td>
					</tr>
					<tr id="Reference.Event.observe">
						<td>observe(element, name, observer, useCapture)</td><td>static</td>
						<td>element: 객체 또는 아이디, name: 이벤트 명 (like 'click', 'load', etc), 
						observer: 이벤트를 다루는 함수, useCapture: <span class="code">true</span>라면, <em>capture</em>내 이벤트를 다루고 <span class="code">false</span>라면 <em>bubbling</em> 내 이벤트를 다룬다.</td>
						<td class="refDescription">이벤트를 위한 이벤트 핸들러 함수를 추가</td>
					</tr>
					<tr id="Reference.Event.stopObserving">
						<td>stopObserving(element, name, observer, useCapture)</td><td>static</td>
						<td>element: 객체 또는 아이디, name: 이벤트 명 (like 'click'), observer: 이벤트를 다루는 함수, useCapture: true이면, <em>capture</em>내 이벤트를 다루고 false이면 <em>bubbling</em> 내 이벤트를 다룬다.</td>
						<td class="refDescription">이벤트로부터 이벤트 핸들러를 제거</td>
					</tr>
					<tr class="privateMember">
						<td>_observeAndCache(element, name, observer, useCapture)</td><td>static</td>
						<td>&nbsp;</td>
						<td class="refDescription">private메소드, 이것에 대해 걱정하지말라</td>
					</tr>
					<tr class="privateMember">
						<td>unloadCache()</td><td>static</td>
						<td>(none)</td>
						<td class="refDescription">private메소드, 이것에 대해 걱정하지말라. 메모리로부터 캐시된 모든 관찰자(observer)를 지운다.</td>
					</tr>
				</tbody></table>

			<p>
				<span class="code">window</span>객체의 이벤트를 로그하기 위한 이벤트 핸들러를 추가하는 객체를 사용하는 방법을 보자.
			</p>
			<pre class="code"><code>&lt;script&gt;
	<strong class="highlite">Event.observe(window, 'load', page_loaded, false);</strong>

	function page_loaded(evt) {
	  <strong class="highlite">Event.observe('parent_node', 'click', item_clicked, false);</strong>
	}
	
	function item_clicked(evt){
		var child = <strong class="highlite">Event.element(evt)</strong>;
		alert('The child node with id=' + child.id + ' was clicked');
		<strong class="highlite">Event.stop(evt)</strong>; //avoid another call related to 'parent_node' itself
	}
&lt;/script&gt;	
...
&lt;div id="parent_node"&gt;
	&lt;div id="child1"&gt;First&lt;/div&gt;
	&lt;div id="child2"&gt;Second&lt;/div&gt;
	&lt;div id="child3"&gt;Third&lt;/div&gt;
&lt;/div&gt;		
			</code></pre>


			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.NewObjects">prototype.js에 새롭게 정의된 객체와 클래스</h4>
			<p>
				라이브러리가 당신을 돕는 다른 방법은 객체지향 디자인과 공통적인 기능을 위한 지원 모두를 구현하는 많은 객체를 제공하는 것이다. 
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.PeriodicalExecuter"><span class="objectClass">PeriodicalExecuter</span> 객체</h4>
			<p>
				이 객체는 주어진 함수를 주어진 시간간격으로 반복적으로 호출하기 위한 로직을 제공한다. 
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.PeriodicalExecuter.ctor">
						<td>[ctor](callback, interval)</td>
						<td>constructor</td><td>callback: 오직 인자로 <span class="code">PeriodcalExecuter</span> 객체 자체가 전달될 함수, interval: 초단위 시간간격</td>
						<td class="refDescription">함수를 반복적으로 호출할 이 객체의 하나의 인스턴스를 생성</td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.registerCallback">
						<td>registerCallback()</td>
						<td>instance</td><td>(none)</td>
						<td class="refDescription">타이머를 다시 셋팅한다.</td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.stop">
						<td>stop()</td>
						<td>instance</td><td>(none)</td>
						<td class="refDescription">타이머를 취소하고 콜백 실행을 하지 않도록 한다. </td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.onTimerEvent" class="privateMember">
						<td>onTimerEvent()</td>
						<td>instance</td><td>(none)</td>
						<td class="refDescription">타이머가 호출하는 메소드. 순차적으로 객체 자체를 전달하는 콜백 메소드를 호출할것이다. </td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>상세설명</th>
					</tr>
					<tr id="Reference.PeriodicalExecuter.callback">
						<td>callback</td>
						<td>Function(objExecuter)</td><td class="refDescription">호출되기 위한 함수.
						objExecuter: <span class="code">PeriodcalExecuter</span>가 호출을 만든다.</td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.timer">
						<td>timer</td><td>Timer</td>
						<td class="refDescription">콜백 메소드를 반복적으로 호출하기 위해 타이머 객체를 다룬다.</td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.frequency">
						<td>frequency</td><td>Number</td>
						<td class="refDescription">이것은 수초내 간격으로 실질적으로 작용</td>
					</tr>
					<tr id="Reference.PeriodicalExecuter.currentlyExecuting">
						<td>currentlyExecuting</td>
						<td>Boolean</td><td class="refDescription">만약 함수 호출이 진행중이라면 표시</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Prototype"><span class="objectClass">Prototype</span> 객체</h4>
			<p>
				<span class="code">Prototype</span> 객체는 사용되는 라이브러리의 버전을 명시하는 것보다 중요한 역활을 가지지 않는다.
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>상세설명</th>
					</tr>
					<tr>
						<td>Version</td><td>String</td><td class="refDescription">라이브러리의 버전</td>
					</tr>
					<tr>
						<td>emptyFunction</td><td>Function()</td><td class="refDescription">비어있는(empty) 함수 객체</td>
					</tr>
					<tr>
						<td>K</td><td>Function(obj)</td>
						<td class="refDescription">주어진 파라미터를 되돌리는 함수 객체</td>
					</tr>
					<tr class="privateMember">
						<td>ScriptFragment</td><td>String</td>
						<td class="refDescription">스크립트를 확인하는 정규식 표현</td>
					</tr>

				</tbody></table>
		
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Enumerable"><span class="objectClass">Enumerable</span> 객체</h4>
			<p>
				<span class="code">Enumerable</span> 객체는 list형태의 구조내에서 항목을 반복하기 위한 좀더 멋진 코드를 작성하는 것을 허용한다. 
			</p>
			<p>
				많은 객체들은 유용한 인터페이스에 영향을 끼치기 위해 <span class="code">Enumerable</span> 을 확장한다. 
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Enumerable.each">
						<td>each(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">주어진 iterator함수를 호출하는 것은 첫번째 인자내 목록으로 각각의 요소와 두번째 인자내 요소의 인덱스 전달한다</td>
					</tr>
					<tr id="Reference.Enumerable.all">
						<td>all([iterator])</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체(선택사항)</td>
						<td class="refDescription">
						이 함수는 주어진 함수를 사용하여 값들의 전체 집합을 테스트하기 위한 방법이다. iterator 함수가 어떤 요소를 위해 <span class="code">false</span>나 <span class="code">null</span>을 반환한다면, all은 <span class="code">false</span>를 반환할것이다. 그렇지 않다면 <span class="code">true</span>를 반환할것이다. iterator가 주어지지 않는다면, 요소 자체가 <span class="code">false</span> 나 <span class="code">null</span>이 아닌지 테스트할것이다. 당신은 "모든 요소가 false가 아닌지 체크한다"와 같이 이것을 읽을수 있다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.any">
						<td>any([iterator])</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체(선택사항)</td>
						<td class="refDescription">
						이 함수는 주어진 함수를 사용하여 값들의 전체 집합을 테스트하기 위한 방법이다. iterator함수가 어떤 요소를 위해 <span class="code">false</span> 나 <span class="code">null</span>을 반환하지 않는다면 <span class="code">any</span>는 <span class="code">true</span>를 반환할것이다. 그렇지 않다면 <span class="code">false</span>를 반환할것이다.  iterator가 주어지지 않는다면, 요소 자체가 <span class="code">false</span> 나 <span class="code">null</span>이 아닌지 테스트할것이다. 당신은 "어느 요소가 false가 아닌지 체크한다"와 같이 이것을 읽을수 있다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.collect">
						<td>collect(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 각각의 요소를 위한 iterator함수를 호출하고 <span class="code">Array</span>로 각각의 결과를 반환한다. 집합내 각각의 요소를 위한 하나의 결과 요소는 같은 순서이다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.detect">
						<td>detect(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 각각의 요소를 위한 iterator함수를 호출하고 true를 반환하는 iterator함수를 야기하는 첫번째 요소를 반환한다. true를 반환하는 요소가 없다면, <span class="code">detect</span>는 <span class="code">null</span>을 반환한다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.entries">
						<td>entries()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">
						<span class="code">toArray()</span>와 같다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.find">
						<td>find(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						<span class="code">detect()</span>와 같다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.findAll">
						<td>findAll(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 각각의 요소를 위한 iterator함수를 호출하고 <span class="code">true</span>로 해석되는 값을 반환하는 iterator함수를 야기하는 모든 요소를 가진 <span class="code">Array</span>을 반환한다. 이 함수는 <span class="code">reject()</span>와는 반대의 함수이다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.grep">
						<td>grep(pattern [, iterator])</td><td>instance</td>
						<td>pattern: 요소를 일치시키기 위해 사용되는 RegExp객체, iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 각각의 요소의 문자열 값을 <span class="code">pattern</span> 정규표현식에 대해 테스트한다. 함수는 정규표현식에 대응되는 모든 요소를 포함하는 <span class="code">Array</span> 를 반환할것이다. iterator함수가 주어진다면, <span class="code">Array</span>는 대응되는 각각의 요소를 가진 iterator를 호출한 결과를 포함할것이다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.include">
						<td>include(obj)</td><td>instance</td>
						<td>obj: 객체</td>
						<td class="refDescription">
						집합내 주어진 객체를 찾도록 시도한다. 객체가 찾아진다면, <span class="code">true</span>를 반환하고 찾지 못한다면 <span class="code">false</span>를 반환한다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.inGroupsOf">
						<td>inGroupsOf(number, fillWith)</td><td>instance</td>
						<td>number: 그룹별 타이머의 수, fillWith: 빈 공간을 채울 필요가 있는 값</td>
						<td class="refDescription">
						첫번째 인자로 지정된 만큼의 항목을 포함하는 그룹별 collection을 반환. 초기 collection의 항목수가 첫번째 인자로 주어진 숫자로 나누어지지 않는다면, 마지막 그룹의 끝에 빈 항목이 <span class="code">null</span>로 채워지거나 두번째 인자값으로 채워진다. 예를 들면, 
						<span class="code">['a','b','c','d'].inGroupsOf(3,'?')</span> 
						는 <span class="code">[ ['a','b','c'] , ['d','?','?'] ]</span>를 생성한다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.inject">
						<td>inject(initialValue, iterator)</td><td>instance</td>
						<td>initialValue: 초기화 값처럼 사용되는 객체, 
						iterator: Function(accumulator, value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						iterator함수를 사용하여 집합의 모든 요소를 조합한다. 호출된 iterator는 accumulator인자에서 이전 반복의 결과를 전달한다. 첫번째 반복은 <span class="code">accumulator</span>인자내 <span class="code">initialValue</span>를 가진다. 마지막 결과는 마지막 반환값이다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.invoke">
						<td>invoke(methodName [, arg1 [, arg2 [...]]])</td><td>instance</td>
						<td>methodName: 각각의 요소내에서 호출될 메소드의 이름, 
						arg1..argN: 메소드 호출로 전달될 인자.</td>
						<td class="refDescription">
						집합의 각각의 요소내 methodName에 의해 명시되는 메소드를 호출하는 것은 주어진 인자(arg1에서 argN) 전달하고 <span class="code">Array</span>객체로 결과를 반환한다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.map">
						<td>map(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						<span class="code">collect()</span>과 같다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.max">
						<td>max([iterator])</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 가장 큰 값이나 iterator가 주어진다면 집합내 각각의 요소를 위한 iterator호출의 가장 큰 결과를 반환한다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.member">
						<td>member(obj)</td><td>instance</td>
						<td>obj: any object</td>
						<td class="refDescription">
						<span class="code">include()</span>와 같다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.min">
						<td>min([iterator])</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 가장 작은 값을 가진 요소나 iterator가 주어진다면 집합내 각각의 요소를 위한 iterator호출의 가장 작은 결과를 가진 요소를 반환한다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.partition">
						<td>partition([iterator])</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						두개의 다른 배열을 포함하는 <span class="code">Array</span>를 반환한다. 첫번째 배열은 <span class="code">true</span>를 반환하는 iterator함수를 야기하는 모든 요소를 포함할것이고 두번째 배열은 남아있는 요소를 포함할것이다. 만약 iterator가 주어지지 않는다면, 첫번째 배열은 <span class="code">true</span>로 해석하는 요소를 포함할것이고 다른 배열은 남아있는 요소를 포함할것이다. 
						</td>
					</tr>
					<tr id="Reference.Enumerable.pluck">
						<td>pluck(propertyName)</td><td>instance</td>
						<td>propertyName : 각각의 요소로부터 읽어들이는 프라퍼티의 이름. 이것은 요소의 인덱스를 포함할수 있다</td>
						<td class="refDescription">
						집합의 각각의 요소내 propertyName에 의해 명시된 프라퍼티에 값을 가져가고 <span class="code">Array</span>객체로 결과를 반환한다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.reject">
						<td>reject(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						집합내 각각의 요소를 위한 iterator함수를 호출하고 <span class="code">false</span>로 해석하는 값을 반환하는 iterator함수를 야기하는 모든 요소를 가진 <span class="code">Array</span>를 반환한다. 이 함수는 <span class="code">findAll()</span>과는 반대되는 함수이다..
						</td>
					</tr>
					<tr id="Reference.Enumerable.select">
						<td>select(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						<span class="code">findAll()</span>과 같다.
						</td>
					</tr>
					<tr id="Reference.Enumerable.sortBy">
						<td>sortBy(iterator)</td><td>instance</td>
						<td>iterator: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						iterator함수 호출결과를 따르는 정렬된 모든 요소를 가진 <span class="code">Array</span>을 반환.
						</td>
					</tr>
					<tr id="Reference.Enumerable.toArray">
						<td>toArray()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">
						집합의 모든 요소를 가지는 <span class="code">Array</span>를 반환.
						</td>
					</tr>
					<tr id="Reference.Enumerable.zip">
						<td>zip(collection1[, collection2 [, ... collectionN [,transform]]])</td><td>instance</td>
						<td>collection1 .. collectionN: 병합될 목록, transform: Function(value, index)를 충족하는 함수 객체</td>
						<td class="refDescription">
						현재의 집합으로 각각의 주어진 집합을 병합한다. 이 병합 작업은 같은 수의 요소를 가진 새로운 배열을 반환한다. 현재 집합과 각각의 요소가 각각의 병합된 집합으로부터 같은 인덱스를 가진 요소의 배열(이것을 하위 배열이라고 부르자.)이다. transform함수가 주어진다면, 각각의 하위 배열은 반환되기 전에 이 함수에 의해 변형딜것이다. 
						빠른 예제 : [1,2,3].zip([4,5,6], [7,8,9]).inspect() 는 "[[1,4,7],[2,5,8],[3,6,9] ]" 를 반환한다.</td>
					</tr>

				</tbody></table>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Hash"><span class="objectClass">Hash</span> 객체</h4>
			<p>
				<span class="code">Hash</span> 객체는 hash구조를 구현한다. 이를테면, Key:Value쌍의 집합.
			</p>
			<p>
				<span class="code">Hash</span>객체내 각각의 항목은 두개의 요소(첫번째는 key, 두번째는 value)를 가진 배열이다. 각각의 항목은 두개의 프라퍼티(<span class="code">key</span> 와 
				<span class="code">value</span>)를 가진다. 
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Hash.keys">
						<td>keys()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">
						모든 항목의 key를 가진 <span class="code">Array</span>을 반환
						</td>
					</tr>
					<tr id="Reference.Hash.values">
						<td>values()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">
						모든 항목의 value를 가진 <span class="code">Array</span>을 반환
						</td>
					</tr>
					<tr id="Reference.Hash.merge">
						<td>merge(otherHash)</td><td>instance</td>
						<td>otherHash: Hash object</td>
						<td class="refDescription">
						hash와 전달된 다른 hash를 조합하고 새로운 결과 hash를 반환
						</td>
					</tr>
					<tr id="Reference.Hash.toQueryString">
						<td>toQueryString()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">
						쿼리 문자열처럼 포맷팅된 문자열로 hash의 모든 항목을 반환. 이를테면 <span class="code">'key1=value1&amp;key2=value2&amp;key3=value3'</span>
						</td>
					</tr>
					<tr id="Reference.Hash.inspect">
						<td>inspect()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">key:value쌍을 가진 hash의 포맷팅된 문자열 표현을 반환하기 위해 변경(오버라이드)</td>
					</tr>
				</tbody></table>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.ObjectRange"><span class="objectClass">ObjectRange</span> 클래스</h4>
			<p><em><a class="code" href="#Reference.Enumerable">Enumerable</a>으로부터 상속</em></p>

			<p>
				상위 경계나 하위 경계로 값들의 범위를 표시
			</p>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Reference.ObjectRange.start">
						<td>start</td><td>(any)</td><td>instance</td>
						<td class="refDescription">범위의 시작값</td>
					</tr>
					<tr id="Reference.ObjectRange.end">
						<td>end</td><td>(any)</td><td>instance</td>
						<td class="refDescription">범위의 마지막값</td>
					</tr>
					<tr id="Reference.ObjectRange.exclusive">
						<td>exclusive</td><td>Boolean</td><td>instance</td>
						<td class="refDescription">경계자체가 범위의 일부인지 판단</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.ObjectRange.ctor">
						<td>[ctor](start, end, exclusive)</td><td>constructor</td><td>start: 시작값, end: 마지막값, exclusive: 경계가 범위내 포함되는가.?</td>
						<td class="refDescription">하나의 range객체를 생성한다. <span class="code">start</span> 에서 <span class="code">end</span>로 범위를 지정한다. <span class="code">start</span> 와 <span class="code">end</span>가 같은 타입의 객체이고 <span class="code">succ()</span>메소드를 가져야만 한다.
						</td>
					</tr>
					<tr id="Reference.ObjectRange.include">
						<td>include(searchedValue)</td><td>instance</td>
						<td>searchedValue: 검색할 값</td>
						<td class="refDescription">
						주어진 값이 범위내 값인지 체크. <span class="code">true</span> 나 <span class="code">false</span>값을 반환한다.
						</td>
					</tr>
				</tbody></table>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Class"><span class="objectClass">Class</span> 객체</h4>
			<p>
				<span class="code">Class</span> 객체는 라이브러리에서 다른 클래스를 선언할때 사용된다. 클래스를 선언할때 이 객체를 사용하는 것은 생성자로 제공되는 <span class="code">initialize()</span>메소드를 지원하기 위한 새로운 클래스를 발생시킨다.
			</p>
			<p>
				아래의 샘플을 보라.
			</p>
			<pre class="code"><code>//declaring the class
<strong class="highlite">var MySampleClass = Class.create();</strong>

//defining the rest of the class implementation
MySampleClass.prototype = {

   initialize: function(message) {
		this.message = message;
   },

   showMessage: function(ajaxResponse) {
      alert(this.message);
   }
};	

//now, let's instantiate and use one object
var myTalker = new MySampleClass('hi there.');
myTalker.showMessage(); //displays alert

			</code></pre>
				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Class.create">
						<td>create(*)</td><td>instance</td><td>(any)</td>
						<td class="refDescription">새로운 클래스를 위한 생성자를 정의</td>
					</tr>
				</tbody></table>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Reference.Ajax"><span class="objectClass">Ajax</span> 객체</h4>
			<p>
				이 객체는 AJAX기능을 제공하는 많은 다른 클래스를 위한 root와 명명공간(namespace)처럼 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Ajax.activeRequestCount">
						<td>activeRequestCount</td><td>Number</td><td>instance</td>
						<td class="refDescription">진행중인 AJAX요청의 수.</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Reference.Ajax.getTransport">
						<td>getTransport()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">새로운 <span class="code">XMLHttpRequest</span> 객체를 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Ajax.Responders"><span class="objectClass">Ajax.Responders</span> 객체</h4>
			<p><em><a class="code" href="#Reference.Enumerable">Enumerable</a> 로 부터 상속되었다</em></p>
			<p>
				이 객체는 Ajax관련 이벤트가 발생할때 호출될 객체의 목록을 보존한다. 예를 들어, 당신이 AJAX작업을 위한 전역 예외 핸들러를 연결하길 원한다면 이 객체를 사용할수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Responders.responders">
						<td>responders</td><td>Array</td><td>instance</td>
						<td class="refDescription">객체의 목록은 AJAX이벤트 알림(notifications)을 위해 등록되었다.</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Responders.register">
						<td>register(responderToAdd)</td><td>instance</td><td>responderToAdd:
						호출될 메소드를 가진 객체.</td>
						<td class="refDescription">
							<span class="code">responderToAdd</span>인자를 전달하는 객체는 AJAX이벤트(이를테면, <span class="code">onCreate</span>, <span class="code">onComplete</span>, 
							<span class="code">onException</span> 등등)처럼 명명된 메소드를 포함해야만 한다. 유사한 이벤트가 발생하면, 적절한 이름을 가진 메소드를 포함하는 모든 등록된 객체가 호출되는 메소드를 가질것이다. 
						</td>
					</tr>
					<tr id="Ajax.Responders.unregister">
						<td>unregister(responderToRemove)</td><td>instance</td><td>responderToRemove:
						list로부터 제거될 객체</td>
						<td class="refDescription">
							<span class="code">responderToRemove</span> 인자로 전달되는 객체는 등록된 객체의 list로부터 제거될것이다.
						</td>
					</tr>
					<tr id="Ajax.Responders.dispatch">
						<td>dispatch(callback, request, transport, json)</td><td>instance</td>
						<td>callback: 보고되는 AJAX이벤트 이름, request: 이벤트를 책임지는 the Ajax.Request 객체, transport: AJAX호출을 가지는 XMLHttpRequest 객체, json: 응답의 X-JSON 헤더(존재할때만)
						</td>
						<td class="refDescription">
							등록된 객체의 목록을 통해 실행하는 것은 <span class="code">callback</span> 인자내 결정된 메소드를 가지는 것을 찾는다. 호출되는 각각의 메소드는 다른 3개의 인자를 전달한다. AJAX응답이 몇몇 JSON컨텐츠를 가지는 <span class="code">X-JSON</span> HTTP 헤더를 포함한다면, 이것은 평가되고 <span class="code">json</span>인자로 전달될것이다. 만약 이벤트가 <span class="code">onException</span>라면, transport인자는 대신에 예외를 가질것이고 <span class="code">json</span>은 전달되지 않을것이다.
						</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Ajax.Base"><span class="objectClass">Ajax.Base</span> 클래스</h4>
			<p>
				이 클래스는 <span class="code">Ajax</span>객체내 정의된 다른  대부분의 클래스를 위한 기본(base)클래스처럼 사용된다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Base.setOptions">
						<td>setOptions(options)</td><td>instance</td><td>options: <a href="#Ajax.options">AJAX 옵션</a></td>
						<td class="refDescription">AJAX작업을 위해 필요한 <a href="#Ajax.options">옵션</a> 셋팅</td>
					</tr>
					<tr id="Ajax.Base.responseIsSuccess">
						<td>responseIsSuccess()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">만약 AJAX작업이 성공한다면 <span class="code">true</span>를 반환하고, 실패한다면 <span class="code">false</span>를 반환</td>
					</tr>
					<tr id="Ajax.Base.responseIsFailure">
						<td>responseIsFailure()</td><td>instance</td><td>(none)</td>
						<td class="refDescription"><span class="code">responseIsSuccess()</span>와는 반대.</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Ajax.Request"><span class="objectClass">Ajax.Request</span> 클래스</h4>
			<p><em><a class="code" href="#Ajax.Base">Ajax.Base</a>로 부터 상속</em></p>
			<p>
				AJAX 작업을 캡슐화
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Request.Events">
						<td>Events</td><td>Array</td><td>static</td>
						<td class="refDescription">AJAX작업중 보고되는 가능한 이벤트/상태의 목록. 목록은 'Uninitialized', 'Loading', 'Loaded', 'Interactive', 그리고 'Complete.'를 포함한다.</td>
					</tr>
					<tr id="Ajax.Request.transport">
						<td>transport</td><td>XMLHttpRequest</td><td>instance</td>
						<td class="refDescription">AJAX작업을 가지는 <span class="code">XMLHttpRequest</span> 객체</td>
					</tr>
					<tr id="Ajax.Request.url">
						<td>url</td><td>String</td><td>instance</td>
						<td class="refDescription">요청에 의해 대상이 되는 URL</td>
					</tr>
				</tbody></table>


				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Request.ctor">
						<td>[ctor](url, options)</td><td>constructor</td><td>url: 꺼내기 위한 url, 
						options: AJAX 옵션</td>
						<td class="refDescription">주어진 <span class="code">옵션</span>을 사용하여 주어진 <span class="code">url</span>을 호출할 이 객체의 하나의 인스턴스를 생성. 
						<strong>중요사항</strong>: 선택된 url은 브라우저의 보안 셋팅을 위한 대상이 될 가치가 없다. 많은 경우 브라우저는 현재 페이지처럼 같은 호스트로부터가 아니라면 url을 가져오지 않을것이다. 당신은 설정을 피하거나 사용자의 브라우저를 제한하기 위한 로컬 url만을 사용할 것이다.</td>
					</tr>
					<tr id="Ajax.Request.evalJSON" class="privateMember">
						<td>evalJSON()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 AJAX응답내 존재하는 <span class="code">X-JSON</span> HTTP헤더의 컨텐츠를 평가하기 위해 내부적으로 호출된다.</td>
					</tr>
					<tr id="Ajax.Request.evalResponse" class="privateMember">
						<td>evalResponse()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. AJAX응답이 <span class="code">text/javascript</span>의 <span class="code">Content-type</span>헤더를 가진다면, 응답 몸체는 평가되고 이 메소드는 사용될것이다.</td>
					</tr>
					<tr id="Ajax.Request.header">
						<td>header(name)</td><td>instance</td><td>name: HTTP header name</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 AJAX응답의 HTTP헤더의 컨텐츠를 가져오기 위해 내부적으로 호출된다.</td>
					</tr>
					<tr id="Ajax.Request.onStateChange" class="privateMember">
						<td>onStateChange()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 AJAX호출 상태 변경시 객체 자체에 의해 호출된다.</td>
					</tr>
					<tr id="Ajax.Request.request" class="privateMember">
						<td>request(url)</td><td>instance</td><td>url: url for the AJAX call</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 생성자를 호출하는 동안 벌써 호출되었다.</td>
					</tr>
					<tr id="Ajax.Request.respondToReadyState" class="privateMember">
						<td>respondToReadyState(readyState)</td><td>instance</td><td>readyState: 상태 숫자값(1 에서  4)</td>
						<td class="refDescription">이 메소드는 대개 외부에서 호출되지 않는다. 이것은 AJAX호출 상태가 변경될때 객체 자체에 의해 호출된다.</td>
					</tr>
					<tr id="Ajax.Request.setRequestHeaders" class="privateMember">
						<td>setRequestHeaders()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 HTTP요청을 하는 동안 보내어질 HTTP헤더를 조합하기 위한 객체 스스로에 의해 호출된다.</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->
			
			<h4 id="Ajax.options"><span class="objectClass">options</span> 인자 객체</h4>
			<p>
				AJAX작업의 중요한 부분은 <span class="code">options</span> 인자이다. 이것은 기대되는 프라퍼티를 가지는 동안 어떠한 객체도 전달될수 있다. 이것은 AJAX호출을 위해 익명 객체를 생성하는 것이 공통적이다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>디폴트</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.options.method">
						<td>method</td><td>String</td><td>'post'</td>
						<td class="refDescription">HTTP요청의 메소드</td>
					</tr>
					<tr id="Ajax.options.parameters">
						<td>parameters</td><td>String</td><td>''</td>
						<td class="refDescription">요청에 전달한 값들의 url형태의 목록</td>
					</tr>
					<tr id="Ajax.options.asynchronous">
						<td>asynchronous</td><td>Boolean</td><td>true</td>
						<td class="refDescription">AJAX호출이 비동기적으로 만들어지는지 표시</td>
					</tr>
					<tr id="Ajax.options.postBody">
						<td>postBody</td><td>String</td><td>undefined</td>
						<td class="refDescription">HTTP POST의 경우 요청의 몸체내 전달되는 내용</td>
					</tr>
					<tr id="Ajax.options.requestHeaders">
						<td>requestHeaders</td><td>Array</td><td>undefined</td>
						<td class="refDescription">요청과 함께 전달되기 위한 HTTP헤더의 목록. 이 목록은 많은 수의 항목을 가져야 한다. 나머지 항목은 사용자 정의 헤더의 이름이다. 그리고 다음의 항목은 헤더의 문자열 값이다. 예제 : <span class="code">['my-header1', 'this is the value', 'my-other-header', 'another value']</span></td>
					</tr>
					<tr id="Ajax.options.onXXXXXXXX">
						<td>onXXXXXXXX</td><td>Function(XMLHttpRequest, Object)</td><td>undefined</td>
						<td class="refDescription">각각의 이벤트/상태가 AJAX호출이 발생하는 동안 도착할때 호출될 사용자정의 함수. 이 옵션에는 "XXXXXXXX"를 위해 <a class="code" href="#Ajax.Request.Events">Ajax.Request.Events</a>,
						와 <a href="http://www.w3.org/Protocols/HTTP/HTRESP.html">HTTP status codes</a>의 상태중에 다양한 대안이 있다. 예를 들어 <span class="code">var myOpts = {onComplete: showResponse, onLoaded: registerLoaded};</span>. 사용되는 함수는 AJAX작업과 평가된 X-JSON응답 HTTP헤더를 포함하는 인자를 가지는 <span class="code">XMLHttpRequest</span>객체를 포함하는 하나의 인자를 받을것이다.</td>
					</tr>
					<tr id="Ajax.options.onSuccess">
						<td>onSuccess</td><td>Function(XMLHttpRequest, Object)</td><td>undefined</td>
						<td class="refDescription">AJAX호출이 성공적으로 완성될때 호출될 사용자정의 함수. 사용되는 함수는 AJAX작업을 가지는 <span class="code">XMLHttpRequest</span>객체를 포함하는 하나의 인자를 받을것이다.</td>
					</tr>
					<tr id="Ajax.options.onFailure">
						<td>onFailure</td><td>Function(XMLHttpRequest, Object)</td><td>undefined</td>
						<td class="refDescription">AJAX호출이 에러를 가진채 끝날때 호출될 사용자정의 함수. 사용되는 함수는 AJAX작업을 가지는 <span class="code">XMLHttpRequest</span>객체를 포함하는 하나의 인자를 받을것이다.</td>
					</tr>
					<tr id="Ajax.options.onException">
						<td>onException</td><td>Function(Ajax.Request, exception)</td><td>undefined</td>
						<td class="refDescription">유효하지 않은 응답이나 유효하지 않은 인자와 같이 예외적인 조건이 클라이언트 측 AJAX호출에서 발생했을때 호출될 사용자정의 함수. 사용된 함수는 AJAX작업을 포장하는 <span class="code">Ajax.Request</span> 객체와 exception객체를 포함하는 두개의 인자를 받을것이다. </td>
					</tr>
					<tr id="Ajax.options.insertion">
						<td>insertion</td><td>an Insertion class</td><td>undefined</td>
						<td class="refDescription">새로운 내용이 삽입될 방법을 판단할 클래스. <a href="#Insertion.Before" class="code">Insertion.Before</a>, <a href="#Insertion.Top" class="code">Insertion.Top</a>, <a href="#Insertion.Bottom" class="code">Insertion.Bottom</a>, 또는 <a href="#Insertion.After" class="code">Insertion.After</a>가 될수 있다. <a class="code" href="#Ajax.Updater">Ajax.Updater</a>객체에만 적용한다. 
						</td>
					</tr>
					<tr id="Ajax.options.evalScripts">
						<td>evalScripts</td><td>Boolean</td><td>undefined, false</td>
						<td class="refDescription">스크립트 블럭이 응답이 도착했을때 평가할지를 판단. <a class="code" href="#Ajax.Updater">Ajax.Updater</a>객체에만 적용</a> objects.</td>
					</tr>
					<tr id="Ajax.options.decay">
						<td>decay</td><td>Number</td><td>undefined, 1</td>
						<td class="refDescription"><a class="code" href="#Ajax.PeriodicalUpdater">Ajax.PeriodicalUpdater</a> 객체는 받은 응답이 마지막 것과 같을때 비율을 새롭게 하여 연속적인 후퇴를 결정. 예를 들어, 당신이 2를 사용한다면, 새롭게 된것중에 하나가 이전것과 같은 결과를 만든후에, 객체는 다음 refresh를 위한 시간의 두배를 기다릴것이다. 이것은 다시 반복한다면, 객체는 4배를 기다릴것이다. 이것을 후퇴를 피하기 위해 정의되지 않거나 1을 사용하도록 남겨두라.</td>
					</tr>
					<tr id="Ajax.options.frequency">
						<td>frequency</td><td>Number</td><td>undefined, 2</td>
						<td class="refDescription">
							초단위의 갱신간격(횟수가 아닌), <a class="code" href="#Ajax.PeriodicalUpdater">Ajax.PeriodicalUpdater</a>객체에만 적용.
						</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Ajax.Updater"><span class="objectClass">Ajax.Updater</span> 클래스</h4>
			<p><em><a class="code" href="#Ajax.Request">Ajax.Request</a>로 부터 상속</em></p>
			<p>
				요청된 url이 당신 페이지의 특정 요소내 직접적으로 삽입하길 원하는 HTML을 반환할때 사용된다. 당신은 url이 도착을 평가할 <span class="code">&lt;script&gt;</span>블럭을 반환할때 이 객체를 사용할수 있다. 스크립트로 작업하기 위해 <span class="code">evalScripts</span> 옵션을 사용하라.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Updater.containers" class="privateMember">
						<td>containers</td><td>Object</td><td>instance</td>
						<td class="refDescription">이 객체는 두개의 프라퍼티(<span class="code">containers.success</span> 는 AJAX호출이 성공할때 사용될것이다. 그리고 AJAX호출이 실패한다면 <span class="code">containers.failure</span>가 사용될것이다.)를 포함한다.</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.Updater.ctor">
						<td>[ctor](container, url, options)</td><td>constructor</td>
						<td>container: 이것은 요소의 id, 요소객체 자체, 또는 두개의 프라퍼티(AJAX호출이 성공했을때 사용될 <strong>object.success</strong> 요소(또는 id), 그리고 AJAX호출이 실패했을때 사용될 <strong>object.failure</strong>요소(또는 id))를 가지는 객체가 될수 있다. url: 가져오기 위한 url, options: <a class="code" href="#Ajax.options">AJAX 옵션</a></td>
						<td class="refDescription">주어진 <span class="code">옵션</span>을 사용하여 주어진 <span class="code">url</span>을 호출할 이 객체의 하나의 인스턴스를 생성.</td>
					</tr>
					<tr id="Ajax.Updater.updateContent" class="privateMember">
						<td>updateContent()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 응답을 받았을때 객체 자체에 의해 호출된다. 이것은 HTML로 적절한 요소를 수정하거나 <span class="code">insertion</span>옵션내 전달되는 함수를 호출할것이다. 이 함수는 두개의 인자(수정되기 위한 요소와 응답 텍스트)를 가지고 호출될것이다.
						</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Ajax.PeriodicalUpdater"><span class="objectClass">Ajax.PeriodicalUpdater</span> 클래스</h4>
			<p><em><a class="code" href="#Ajax.Base">Ajax.Base</a>로 부터 상속</em></p>
			<p>
				이 클래스는 반복적으로 인스턴스화하고 페이지에서 요소를 새롭게 하거나 <span class="objectClass">Ajax.Updater</span>가 수행할수 있는 다른 작업중 어느것을 수행하기 위한 <span class="objectClass">Ajax.Updater</span>객체를 사용한다. 좀더 많은 정보를 위해 <a href="#Ajax.Updater">Ajax.Updater 참조</a>를 체크하라.

			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.contaier">
						<td>container</td><td>Object</td><td>instance</td>
						<td class="refDescription">이 값은 <span class="code">Ajax.Updater</span>생성자에 일관적으로 전달될것이다.</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.url">
						<td>url</td><td>String</td><td>instance</td>
						<td class="refDescription">이 값은 <span class="code">Ajax.Updater</span>의 생성자에 일관적으로 전달될것이다.</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.frequency">
						<td>frequency</td><td>Number</td><td>instance</td>
						<td class="refDescription">초단위의 refresh간격. 디폴트는 2초. 이 숫자는 <span class="code">Ajax.Updater</span> 객체를 호출할때 현재 <span class="code">축소(decay)</span>에 의해 곱해질것이다.
						</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.decay">
						<td>decay</td><td>Number</td><td>instance</td>
						<td class="refDescription">작업을 재-수행할때 적용될 축소(decay)레벨을 유지</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.updater" class="privateMember">
						<td>updater</td><td><a href="#Ajax.Updater">Ajax.Updater</a></td><td>instance</td>
						<td class="refDescription">가장 최신에 사용된 <span class="code">Ajax.Updater</span> 객체</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.timer" class="privateMember">
						<td>timer</td><td>Object</td><td>instance</td>
						<td class="refDescription">다른 refresh를 위한 시각일때 객체를 알리기 위해 사용되는 자바스크립트 타이머.</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.ctor">
						<td>[ctor](container, url, options)</td><td>constructor</td>
						<td>container:이것은 요소의 id, 요소객체 자체, 또는 두개의 프라퍼티(AJAX호출이 성공할때 사용될 <span class="code">object.success</span> 요소(나 id), AJAX호출이 실패할때 사용할 <span class="code">object.failure</span> 요소(나 id))를 가지는 객체가 될수 있다. url: 가져오기 위한 url, options: <a class="code" href="#Ajax.options">AJAX 옵션</a></td>
						<td class="refDescription">주어진 <span class="code">옵션</span>을 사용하여 주어진 <span class="code">url</span>을 호출할 이 객체의 하나의 인스턴스를 생성</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.start" class="privateMember">
						<td>start()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것의 정기적인 작업 수행을 시작하기 위해 객체 자체에 의해 호출된다.
						</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.stop">
						<td>stop()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">
							주기를 가지는 작업 수행을 종료하도록 한다. 종료후, 객체는 <span class="code">onComplete</span> 옵션에 주어진 콜백을 호출할것이다. 
						</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.updateComplete" class="privateMember">
						<td>updateComplete()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 요청을 완성한 후에 사용되는 <span class="code">Ajax.Updater</span>에 의해 호출된다. 이것은 다음 refresh스케줄링 하기 위해 사용된다.
						</td>
					</tr>
					<tr id="Ajax.PeriodicalUpdater.onTimerEvent" class="privateMember">
						<td>onTimerEvent()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 다음 수정을 위한 시각일때 내부적으로 호출된다.
						</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Element"><span class="objectClass">Element</span> 객체</h4>
			<p>
				이 객체는 DOM내 요소를 변경하기 위해 몇몇 유틸리티성 함수들을 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Element.addClassName">
						<td>addClassName(element, className)</td><td>instance</td><td>element: element 객체 또는 아이디, 
						className: CSS 클래스명</td>
						<td class="refDescription">주어진 class명을 요소의 class명으로 추가</td>
					</tr>
					<tr id="Element.classNames">
						<td>classNames(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">주어진 element와 관련된 CSS 클래스명을 표시하는 <span class="code">Element.ClassNames</span> 객체를 반환</td>
					</tr>
					<tr id="Element.cleanWhitespace">
						<td>cleanWhitespace(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">요소의 자식노드에서 공백을 제거</td>
					</tr>
					<tr id="Element.empty">
						<td>empty(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">element태그가 비어있는지(또는 공백만을 가지고 있는지) 표시하는 <span class="code">Boolean</span>값을 반환</td>
					</tr>
					<tr id="Element.getDimensions">
						<td>getDimensions(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">
							element의 면적(dimensions)을 반환. 반환된 값은 두개의 프라퍼티(<span class="code">height</span> 와 <span class="code">width</span>)를 가지는 객체이다. 
						</td>
					</tr>
					<tr id="Element.getHeight">
						<td>getHeight(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">요소의 <span class="code">offsetHeight</span>값을 반환</td>
					</tr>
					<tr id="Element.getStyle">
						<td>getStyle(element, cssProperty)</td><td>instance</td><td>element: element 객체 또는 아이디, 
						cssProperty : CSS프라퍼티('prop-name' 또는 'propName' 가 작동하는 형태)의 이름</td>
						<td class="refDescription">
						주어진 element내 CSS프라퍼티의 값을 반환하거나 존재하지 않는다면 <span class="code">null</span> 을 반환</td>
					</tr>
					<tr id="Element.hasClassName">
						<td>hasClassName(element, className)</td><td>instance</td><td>element: element 객체 또는 아이디, 
						className: CSS 클래스명</td>
						<td class="refDescription">요소가 class명중에 하나로 주어진 class명을 가진다면 <span class="code">true</span>를 반환</td>
					</tr>
					<tr id="Element.hide">
						<td>hide(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">style.display</span>를 <span class="code">'none'</span>로 셋팅하여 각각의 요소를 숨긴다.</td>
					</tr>
					<tr id="Element.makeClipping">
						<td>makeClipping(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription"></td>
					</tr>
					<tr id="Element.makePositioned">
						<td>makePositioned(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">element의 <span class="code">style.position</span>  을 <span class="code">'relative'</span>로 변경</td>
					</tr>
					<tr id="Element.remove">
						<td>remove(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">문서로 부터 요소를 제거한다.</td>
					</tr>
					<tr id="Element.removeClassName">
						<td>removeClassName(element, className)</td><td>instance</td><td>element: element 객체 또는 아이디, 
						className: CSS 클래스명</td>
						<td class="refDescription">요소의 class명으로 부터 주어진 class명을 제거</td>
					</tr>
					<tr id="Element.scrollTo">
						<td>scrollTo(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">창을 element위치로 스크롤</td>
					</tr>
					<tr id="Element.setStyle">
						<td>setStyle(element, cssPropertyHash)</td><td>instance</td><td>element: element 객체 또는 아이디, 
						cssPropertyHash : 적용되기 위한 스타일을 가지는 Hash객체</td>
						<td class="refDescription"><span class="code">cssPropertyHash</span> 인자내 값에 따라, 주어진 element내 CSS프라퍼티의 값을 셋팅.</td>
					</tr>
					<tr id="Element.show">
						<td>show(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">style.display</span>를 <span class="code">''</span>로 다시 셋팅하여 각각의 요소를 보여준다.</td>
					</tr>
					<tr id="Element.toggle">
						<td>toggle(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">각각의 전달된 요소의 가시성(visibility)을 토글(toggle)한다.</td>
					</tr>
					<tr id="Element.undoClipping">
						<td>undoClipping(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription"></td>
					</tr>
					<tr id="Element.undoPositioned">
						<td>undoPositioned(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">element의 <span class="code">style.position</span> 을 <span class="code">''</span>으로 초기화</td>
					</tr>
					<tr id="Element.update">
						<td>update(element, html)</td><td>instance</td><td>element: element 객체 또는 아이디, html: html content</td>
						<td class="refDescription">
							주어진 html인자를 가지는 요소의 내부 html을 대체. 주어진 html이 <span class="code">&lt;script&gt;</span>블럭을 포함한다면, 그것들은 포함되지는 않지만 평가될것이다.
						</td>
					</tr>
					<tr id="Element.visible">
						<td>visible(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">요소가 눈에 보이는지 표시하는 <span class="code">Boolean</span>값을 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Element.ClassNames"><span class="objectClass">Element.ClassNames</span> 클래스</h4>
			<p><em><a class="code" href="#Reference.Enumerable">Enumerable</a>로 부터 상속</em></p>

			<p>
				element에 관련된 CSS 클래스명의 collection을 표시
			</p>


				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Element.ClassNames.ctor">
						<td>[ctor](element)</td><td>constructor</td><td>element: any DOM element 객체 또는 아이디</td>
						<td class="refDescription">주어진 element의 CSS 클래스명을 표시하는 <span class="code">Element.ClassNames</span> 객체를 생성
						</td>
					</tr>
					<tr id="Element.ClassNames.add">
						<td>add(className)</td><td>instance</td>
						<td>className: CSS 클래스 명</td>
						<td class="refDescription">
						element에 관련된 class명의 리스트에 주어진 CSS 클래스명을 추가
						</td>
					</tr>
					<tr id="Element.ClassNames.remove">
						<td>remove(className)</td><td>instance</td>
						<td>className: CSS 클래스 명</td>
						<td class="refDescription">
						element에 관련된 class명의 리스트로부터 주어진 CSS 클래스명을 제거
						</td>
					</tr>
					<tr id="Element.ClassNames.set">
						<td>set(className)</td><td>instance</td>
						<td>className: CSS 클래스 명</td>
						<td class="refDescription">	
						주어진 CSS 클래스명을 가진 element을 결합, element로부터 다른 class명을 제거.
						</td>
					</tr>
				</tbody></table>


			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Abstract"><span class="objectClass">Abstract</span> 객체</h4>
			<p>
				이 객체는 라이브러리내 다른 클래스를 위한 root처럼 제공한다. 이것은 어떤 프라퍼티나 메소드도 가지지 않는다. 이 객체에 정의된 클래스는 전통적인 추상 클래스처럼 처리된다.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>
			
<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Abstract.Insertion"><span class="objectClass">Abstract.Insertion</span> 클래스</h4>
			<p>
				이 클래스는 동적으로 내용물을 추가할 다른 클래스를 위한 기본 클래스처럼 사용된다. 이 클래스는 추상 클래스처럼 사용된다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Abstract.Insertion.ctor">
						<td>[ctor](element, content)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, content: 삽입되는 HTML</td>
						<td class="refDescription">동적 내용물 삽입을 도울 객체를 생성</td>
					</tr>
					<tr id="Abstract.Insertion.contentFromAnonymousTable" class="privateMember">
						<td>contentFromAnonymousTable()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription"></td>
					</tr>
				</tbody></table>


				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>종류</th><th>상세설명</th>
					</tr>
					<tr id="Abstract.Insertion.adjacency" class="privateMember">
						<td>adjacency</td><td>String</td><td>static, parameter</td>
						<td class="refDescription">내용물이 주어진 요소에 대해 상대적으로 위치할 지점을 명시하는 파라미터. 가능한 값은 <span class="code">'beforeBegin'</span>, <span class="code">'afterBegin'</span>, <span class="code">'beforeEnd'</span>, 그리고 <span class="code">'afterEnd'</span>.</td>
					</tr>
					<tr id="Abstract.Insertion.element">
						<td>element</td><td>Object</td><td>instance</td>
						<td class="refDescription">삽입이 상대적으로 만들어질 요소객체</td>
					</tr>
					<tr id="Abstract.Insertion.content">
						<td>content</td><td>String</td><td>instance</td>
						<td class="refDescription">삽입될 HTML</td>
					</tr>
				</tbody></table>

			
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Insertion"><span class="objectClass">Insertion</span> 객체</h4>
			<p>
				이 객체는 라이브러리내 다른 클래스를 위한 root처럼 제공한다. 이것은 어떠한 프라퍼티나 메소드를 가지지 않는다. 이 객체에 정의된 클래스는 전통적인 추상 클래스처럼 처리된다.
			</p>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Insertion.Before"><span class="objectClass">Insertion.Before</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>로 부터 상속</em></p>
			<p>
				요소 앞에 HTML삽입
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Insertion.Before.ctor">
						<td>[ctor](element, content)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, content: 삽입되는 HTML</td>
						<td class="refDescription">Abstract.Insertion</span>으로 부터 상속. 동적으로 내용물을 삽입하는 것을 돕는 객체를 생성</td>
					</tr>
				</tbody></table>

			<p>
				다음의 코드는
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;

&lt;script&gt; <strong class="highlite">new Insertion.Before('person', 'Chief ')</strong>; &lt;/script&gt;
			</code></pre>
			<p>
				다음처럼 HTML이 변경될것이다.
			</p>
			<pre class="code"><code>
&lt;br/&gt;Hello, <strong class="highlite">Chief </strong>&lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;	
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Insertion.Top"><span class="objectClass">Insertion.Top</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>로 부터 상속</em></p>
			<p>
				요소아래의 첫번째 자식으로 HTML을 삽입. 이 내용물은 요소의 열기 태그뒤에 위치할것이다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Insertion.Top.ctor">
						<td>[ctor](element, content)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, content: 삽입되는 HTML</td>
						<td class="refDescription"><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>으로부터 상속. 동적으로 내용물을 삽입하는 것을 돕는 객체 생성</td>
					</tr>
				</tbody></table>

			<p>
				다음의 코드는
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;

&lt;script&gt; <strong class="highlite">new Insertion.Top('person', 'Mr. ')</strong>; &lt;/script&gt;
			</code></pre>
			<p>
				다음처럼 HTML이 변경될것이다.
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;<strong class="highlite">Mr. </strong>Wiggum. How's it going?&lt;/span&gt;	
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Insertion.Bottom"><span class="objectClass">Insertion.Bottom</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>로 부터 상속</em></p>
			<p>
				요소아래의 마지막 자식으로 HTML삽입. 내용물은 요소의 닫기 태그앞에 위치할것이다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Insertion.Bottom.ctor">
						<td>[ctor](element, content)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, content: 삽입되는 HTML</td>
						<td class="refDescription"><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>로 부터 상속. 동적으로 내용물을 삽입하는 것을 돕는 객체 생성</td>
					</tr>
				</tbody></table>

			<p>
				다음의 코드는
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;

&lt;script&gt; <strong class="highlite">new Insertion.Bottom('person', " What's up?")</strong>; &lt;/script&gt;
			</code></pre>
			<p>
				다음처럼 HTML이 변경될것이다.
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?<strong class="highlite"> What's up?</strong>&lt;/span&gt;	
			</code></pre>
			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Insertion.After"><span class="objectClass">Insertion.After</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>로 부터 상속</em></p>
			<p>
				요소의 닫기 태그뒤 HTML삽입
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Insertion.After.ctor">
						<td>[ctor](element, content)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, content: 삽입되는 HTML</td>
						<td class="refDescription"><a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>으로부터 상속. 동적으로 내용물을 삽입하는 것을 돕는 객체 생성</td>
					</tr>
				</tbody></table>

			<p>
				다음의 코드는
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;

&lt;script&gt; <strong class="highlite">new Insertion.After('person', ' Are you there?')</strong>; &lt;/script&gt;
			</code></pre>
			<p>
				다음처럼 HTML이 변경될것이다.
			</p>
			<pre class="code"><code>&lt;br/&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;<strong class="highlite"> Are you there?</strong>	
			</code></pre>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Field"><span class="objectClass">Field</span> 객체</h4>
			<p>
				This object provides some utility functions for working with input fields in forms.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Field.activate">
						<td>activate(field)</td><td>instance</td><td>field: field element 객체 또는 아이디</td>
						<td class="refDescription">포커스를 이동하고 텍스트 선택을 지원하는 field내 값을 선택</td>
					</tr>
					<tr id="Field.clear">
						<td>clear(field)</td><td>instance</td><td>field: field element 객체 또는 아이디 </td>
						<td class="refDescription">field요소로부터 각각 전달된 값을 지움(clear)</td>
					</tr>
					<tr id="Field.disable">
						<td>disable(field)</td><td>instance</td><td>field: field element 객체 또는 아이디 </td>
						<td class="refDescription">폼 필드 요소를 사용하지 못하도록 만든다. 요소 객체를 반환한다. </td>
					</tr>
					<tr id="Field.enable">
						<td>enable(field)</td><td>instance</td><td>field: field element 객체 또는 아이디 </td>
						<td class="refDescription">폼 필드 요소를 사용가능하도록 만든다. 요소 객체를 반환한다.</td>
					</tr>
					<tr id="Field.focus">
						<td>focus(field)</td><td>instance</td><td>field: field element 객체 또는 아이디</td>
						<td class="refDescription">주어진 폼 field로 입력 포커스 이동</td>
					</tr>
					<tr id="Field.getValue">
						<td>getValue(field)</td><td>instance</td><td>field: field element 객체 또는 아이디 </td>
						<td class="refDescription">필드에 입력되거나 선택된 값을 반환한다. </td>
					</tr>
					<tr id="Field.present">
						<td>present(field)</td><td>instance</td><td>field: field element 객체 또는 아이디 </td>
						<td class="refDescription">모든 폼 field가 빈값이 아니라면 <span class="code">true</span>를 반환</td>
					</tr>
					<tr id="Field.select">
						<td>select(field)</td><td>instance</td><td>field: field element 객체 또는 아이디</td>
						<td class="refDescription">텍스트 선택을 지원하는 field내 값을 선택</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form"><span class="objectClass">Form</span> 객체</h4>
			<p>
				이 객체는 데이터 항목 폼과 그것들의 입력 field와 작동하기 위한 몇몇 유틸리티성 함수를 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.serialize">
						<td>serialize(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">'field1=value1&amp;field2=value2&amp;field3=value3'</span>처럼 field명과 값의 url형태의 목록을 반환</td>
					</tr>
					<tr id="Form.findFirstElement">
						<td>findFirstElement(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">form에서 첫번째로 사용가능한 필드 element를 반환</td>
					</tr>
					<tr id="Form.getElements">
						<td>getElements(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">폼내 모든 입력 field를 포함하는 <span class="code">Array</span> 반환</td>
					</tr>
					<tr id="Form.getInputs">
						<td>getInputs(form [, typeName [, name]])</td><td>instance</td>
						<td>form: form element 객체 또는 아이디, typeName: input요소의 타입,
						name: input요소명.</td>
						<td class="refDescription">폼내 모든 <span class="code">&lt;input&gt;</span>요소를 포함하는 <span class="code">Array</span> 반환. 선택적으로 목록은 요소의 <span class="code">type</span>이나 <span class="code">name</span>속성에 의해 필터링 될수 있다.</td>
					</tr>
					<tr id="Form.disable">
						<td>disable(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">폼내 모든 입력 field를 사용불가상태로 만들기</td>
					</tr>
					<tr id="Form.enable">
						<td>enable(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">폼내 모든 입력 field를 사용가능하게 만들기</td>
					</tr>
					<tr id="Form.focusFirstElement">
						<td>focusFirstElement(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">첫번째 가시성을 활성화하고, 폼내 입력 field를 가능하게 하기</td>
					</tr>
					<tr id="Form.reset">
						<td>reset(form)</td><td>instance</td><td>form: form element 객체 또는 아이디</td>
						<td class="refDescription">폼을 리셋하기. form객체의 <span class="code">reset()</span>메소드와 같다.</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.Element"><span class="objectClass">Form.Element</span> 객체</h4>
			<p>
				이 객체는 폼요소와 작동하기 위한 몇몇 유틸리티성 함수를 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.Element.serialize">
						<td>serialize(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">'elementName=elementValue'</span>처럼 요소의 name=value 짝을 반환</td>
					</tr>
					<tr id="Form.Element.getValue">
						<td>getValue(element)</td><td>instance</td><td>element: element 객체 또는 아이디</td>
						<td class="refDescription">요소의 값을 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.Element.Serializers"><span class="objectClass">Form.Element.Serializers</span> 객체</h4>
			<p>
				이 객체는 폼요소의 현재 값을 가져오기 위해 라이브러리 내부적으로 사용되는 몇몇 유틸리티성 함수를 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.Element.Serializers.inputSelector">
						<td>inputSelector(element)</td><td>instance</td><td>element: radio 버튼이나 checkbox처럼 <em>checked</em>프라퍼티를 가지는 form요소의 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">['elementName', 'elementValue']</span>처럼 요소의 이름과 값을 가지는 <span class="code">Array</span>을 반환</td>
					</tr>
					<tr id="Form.Element.Serializers.textarea">
						<td>textarea(element)</td><td>instance</td><td>element: textbox, button 또는 password필드처럼 <em>value</em>프라퍼티를 가지는 form요소의 객체 또는 아이디.</td>
						<td class="refDescription"><span class="code">['elementName', 'elementValue']</span>처럼 요소의 이름과 값을 가지는 <span class="code">Array</span>를 반환</td>
					</tr>
					<tr id="Form.Element.Serializers.select">
						<td>select(element)</td><td>instance</td><td>element: &lt;select&gt; 요소의 객체 또는 아이디</td>
						<td class="refDescription"><span class="code">['elementName', 'selOpt1 selOpt4 selOpt9']</span>처럼 요소의 이름과 모든 선택된 옵션의 값이나 텍스트를 가지는 <span class="code">Array</span>를 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Abstract.TimedObserver"><span class="objectClass">Abstract.TimedObserver</span> 클래스</h4>
			<p>
				이 클래스는 값이 변경(또는 프라퍼티가 클래스정의를 얻어내는)될때까지 하나의 요소를 모니터링할 다른 클래스를 위한 기본클래스처럼 사용된다. 이 클래스는 추상클래스처럼 사용된다.
			</p>
			<p>
				하위클래스는 요소의 입력값, style프라퍼티중 하나, 또는 테이블내 row의 수, 또는 당신이 추적하고자 하는 모든것을 모니터링하기 위해 생성될수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Abstract.TimedObserver.ctor">
						<td>[ctor](element, frequency, callback)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, frequency: 초단위 간격, callback: 요소가 변경될때 호출되는 함수</td>
						<td class="refDescription">요소를 모니터링할 객체 생성</td>
					</tr>
					<tr id="Abstract.TimedObserver.getValue" class="privateMember">
						<td>getValue()</td><td>instance, abstract</td>
						<td>(none)</td>
						<td class="refDescription">클래스는 요소에서 모니터링이 되는 현재값이 무엇인지 판단하기 위햔 메소드를 구현해야만 한다. </td>
					</tr>
					<tr id="Abstract.TimedObserver.registerCallback" class="privateMember">
						<td>registerCallback()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 요소 모니터링릉 시작하기 위한 객체 자체에 의해 호출된다.
						</td>
					</tr>
					<tr id="Abstract.TimedObserver.onTimerEvent" class="privateMember">
						<td>onTimerEvent()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 요소를 체크하기 위해 정기적으로 객체 자체에 의해 호출된다.
						</td>
					</tr>
				</tbody></table>


				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>Property</th><th>Type</th><th>Description</th>
					</tr>
					<tr id="Abstract.TimedObserver.element">
						<td>element</td><td>Object</td>
						<td class="refDescription">모니터링되는 요소객체.</td>
					</tr>
					<tr id="Abstract.TimedObserver.frequency">
						<td>frequency</td><td>Number</td><td class="refDescription">이것은 체크사이에 초단위 간격으로 이루어진다.</td>
					</tr>
					<tr id="Abstract.TimedObserver.callback">
						<td>callback</td><td>Function(Object, String)</td><td class="refDescription">요소가 변경될때마다 호출되기 위한 함수. 이것은 요소객체와 새로운 값을 받을것이다.</td>
					</tr>
					<tr id="Abstract.TimedObserver.lastValue" class="privateMember">
						<td>lastValue</td><td>String</td><td class="refDescription">요소내 확인되는 마지막 값</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.Element.Observer"><span class="objectClass">Form.Element.Observer</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.TimedObserver">Abstract.TimedObserver</a>로 부터 상속</em></p>
			<p>
				폼 입력 요소의 값을 모니터링하는 <span class="code">Abstract.TimedObserver</span>의 구현물. 값 변경을 보고하는 이벤트를 드러내지 않는 요소를 모니터링하고자 할때 이 클래스를 사용하라. 이 경우 당신은 <a class="code" href="#Form.Element.EventObserver">Form.Element.EventObserver</a> 클래스를 대신 사용할수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.Element.Observer.ctor">
						<td>[ctor](element, frequency, callback)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, frequency: 초단위 간격, callback: 요소가 변경될때 호출되는 함수</td>
						<td class="refDescription"><a class="code" href="#Abstract.TimedObserver">Abstract.TimedObserver</a>으로부터 상속. 요소의 <span class="code">value</span>프라퍼티를 모니터링할 객체를 생성.</td>
					</tr>
					<tr id="Form.Element.Observer.getValue" class="privateMember">
						<td>getValue()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">요소의 값을 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.Observer"><span class="objectClass">Form.Observer</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.TimedObserver">Abstract.TimedObserver</a>로 부터 상속</em></p>
			<p>
				폼내 데이터 항목 요소의 값이 변경하는지를 모니터링하는 <span class="code">Abstract.TimedObserver</span>의 구현물. 당신이 값 변경을 보고하는 이벤트를 드러내지 않는 요소를 포함하는 폼을 모니터링하고자 할때 이 클래스를 사용하라. 이 경우 당신은 <a class="code" href="#Form.EventObserver">Form.EventObserver</a> 클래스를 대신 사용할수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.Observer.ctor">
						<td>[ctor](form, frequency, callback)</td><td>constructor</td>
						<td>form: form 객체 또는 아이디, frequency: 초단위 간격, form내 데이터 항목 요소가 변경될때 호출되는 콜백 함수</td>
						<td class="refDescription"><a class="code" href="#Abstract.TimedObserver">Abstract.TimedObserver</a>로부터 상속. 변경하기 위한 폼을 모니터링할 객체 생성.</td>
					</tr>
					<tr id="Form.Observer.getValue" class="privateMember">
						<td>getValue()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">모든 폼의 데이터의 직렬화를 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Abstract.EventObserver"><span class="objectClass">Abstract.EventObserver</span> 클래스</h4>
			<p>
				이 클래스는 요소를 위해 값-변경 이벤트가 발생할때마다 콜백함수를 수행하는 다른 클래스를 위한 기본 클래스처럼 사용된다.
			</p>
			<p>
				<span class="code">Abstract.EventObserver</span> 타입의 다중 객체는 다른것을 지우지 않고 같은 요소로 묶일수 있다. 콜백은 요소에 할당되는 순서대로 수행될것이다.
			</p>
			<p>
				트리거 형태의 이벤트는 radio버튼과 checkbox를 위해서는 <span class="code">onclick</span>이고 대개의 textbox와 리스트박스/드랍다운을 위해서는 <span class="code">onchange</span>이다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Abstract.EventObserver.ctor">
						<td>[ctor](element, callback)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, callback: function to be called when the event happens</td>
						<td class="refDescription">요소를 모니터링할 객체 생성.</td>
					</tr>
					<tr id="Abstract.EventObserver.getValue" class="privateMember">
						<td>getValue()</td><td>instance, abstract</td>
						<td>(none)</td>
						<td class="refDescription">클래스는 요소에서 모니터링이 되는 현재값이 무엇인지 판단하기 위햔 메소드를 구현해야만 한다.</td>
					</tr>
					<tr id="Abstract.EventObserver.registerCallback" class="privateMember">
						<td>registerCallback()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 요소의 이벤트를 자체적으로 묶는 객체에 의해 호출된다.
						</td>
					</tr>
					<tr id="Abstract.EventObserver.registerForCallbacks" class="privateMember">
						<td>registerFormCallbacks()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 폼내 각각의 데이터 항목 요소의 이벤트로 자체적으로 묶기 위한 객체에 의해 호출된다.
						</td>
					</tr>
					<tr id="Abstract.EventObserver.onElementEvent" class="privateMember">
						<td>onElementEvent()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">이 메소드는 대개 외부적으로 호출되지 않는다. 이것은 요소의 이벤트로 묶일것이다.
						</td>
					</tr>
				</tbody></table>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>프라퍼티</th><th>타입</th><th>상세설명</th>
					</tr>
					<tr id="Abstract.EventObserver.element">
						<td>element</td><td>Object</td>
						<td class="refDescription">모니터링되는 요소객체</td>
					</tr>
					<tr id="Abstract.EventObserver.callback">
						<td>callback</td><td>Function(Object, String)</td><td class="refDescription">요소가 변경될때마다 호출되기 위한 함수. 이것은 요소객체와 새로운 값을 받을것이다.</td>
					</tr>
					<tr id="Abstract.EventObserver.lastValue" class="privateMember">
						<td>lastValue</td><td>String</td><td class="refDescription">요소내 확인되는 마지막 값</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.Element.EventObserver"><span class="objectClass">Form.Element.EventObserver</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.EventObserver">Abstract.EventObserver</a>로 부터 상속</em></p>
			<p>
				요소내 값 변경을 감지하기 위한 폼 데이터 항목 요소의 적절한 이벤트를 위한 콜백 함수를 수행하는 <span class="code">Abstract.EventObserver</span>의 구현물. 만약 요소가 변경을 보고하는 이벤트를 드러내지 않는다면, 당신은 <a class="code" href="#Form.Element.Observer">Form.Element.Observer</a> 클래스를 대신 사용할수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.Element.EventObserver.ctor">
						<td>[ctor](element, callback)</td><td>constructor</td>
						<td>element: element 객체 또는 아이디, callback: 이벤트가 발생할때 호출될 함수</td>
						<td class="refDescription"><a class="code" href="#Abstract.EventObserver">Abstract.EventObserver</a>로 부터 상속. 요소의 <span class="code">value</span>프라퍼티를 모니터링할 객체 생성.</td>
					</tr>
					<tr id="Form.Element.EventObserver.getValue" class="privateMember">
						<td>getValue()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">요소의 값 반환</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>

<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Form.EventObserver"><span class="objectClass">Form.EventObserver</span> 클래스</h4>
			<p><em><a class="code" href="#Abstract.EventObserver">Abstract.EventObserver</a>로 부터 상속</em></p>
			<p>
				값이 변결될때 감지하기 위한 요소의 이벤트를 사용하여 폼내 포함되는 어느 데이터 항목 요소에 변경을 모니터링하는 <span class="code">Abstract.EventObserver</span>의 구현물. 만약 폼이 변경을 보고하는 이벤트를 드러내지 않는 요소를 포함한다면, 당신은 <a class="code" href="#Form.Observer">Form.Observer</a> 클래스를 대신 사용할수 있다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Form.EventObserver.ctor">
						<td>[ctor](form, callback)</td><td>constructor</td>
						<td>form: form 객체 또는 아이디, callback: form내 데이터 항목 요소가 변경될때 호출되는 함수</td>
						<td class="refDescription"><a class="code" href="#Abstract.EventObserver">Abstract.EventObserver</a>로부터 상속. 변경을 위해 폼을 모니터링할 객체 생성.</td>
					</tr>
					<tr id="Form.EventObserver.getValue" class="privateMember">
						<td>getValue()</td><td>instance</td>
						<td>(none)</td>
						<td class="refDescription">모든 폼의 데이터 직렬화를 반환.</td>
					</tr>
				</tbody></table>

			<p class="backToc"><a href="#toc">toc</a></p>


<!-- ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// -->

			<h4 id="Position"><span class="objectClass">Position</span> 객체 (예비 문서)</h4>
			<p>
				이 객체는 요소 위치할당을 작업할때 돕는 수많은 함수를 제공한다.
			</p>

				<table class="reference" border="1" cellspacing="0">
					<col class="titleCol">
					<tbody><tr>
						<th>메소드</th><th>종류</th><th>인자</th><th>상세설명</th>
					</tr>
					<tr id="Position.prepare">
						<td>prepare()</td><td>instance</td><td>(none)</td>
						<td class="refDescription">스크롤 위치내 변경을 수용하기 위한 <span class="code">deltaX</span> 와 <span class="code">deltaY</span> 프라퍼티 조정. 페이지 스크롤후 <span class="code">withinIncludingScrolloffset</span>를 호출하기 전에 이 메소드를 호출하는 것을 기억하라.</td>
					</tr>
					<tr id="Position.realOffset">
						<td>realOffset(element)</td><td>instance</td><td>element: object</td>
						<td class="refDescription">요소에 영향을 끼치는 어느 스크롤 offset를 포함하는 요소의 정확한 스크롤 offset를 가진 <span class="code">Array</span>을 반환. 이 결과 배열은 <span class="code">[total_scroll_left, total_scroll_top]</span>과 유사하다.</td>
					</tr>
					<tr id="Position.cumulativeOffset">
						<td>cumulativeOffset(element)</td><td>instance</td><td>element: object</td>
						<td class="refDescription">위치가 할당된 부모 요소에 의해 부과된 어느 offset를 포함하는 요소의 정확한 위치가 할당된 offset를 가진 <span class="code">Array</span>을 반환. 결과 배열은 <span class="code">[total_offset_left, total_offset_top]</span>과 유사하다.</td>
					</tr>
					<tr id="Position.within">
						<td>within(element, x, y)</td><td>instance</td><td>element: object, x 와 y: 위치 조정</td>
						<td class="refDescription">만약 주어진 지점이 주어진 요소의 직사각형내 조정이 되는지 테스트</td>
					</tr>
					<tr id="Position.withinIncludingScrolloffsets">
						<td>withinIncludingScrolloffsets(element, x, y)</td><td>instance</td><td>element: object, x and y: coordinates of a point</td>
						<td class="refDescription">&nbsp;</td>
					</tr>
					<tr id="Position.overlap">
						<td>overlap(mode, element)</td><td>instance</td><td>mode: 'vertical' or 'horizontal', element: object</td>
						<td class="refDescription"><span class="code">within()</span>은 이 메소드가 호출되기 전에 호출될 필요가 있다. 이 메소드는 요소에서 겹치는 것을 조정하는 세분화정도를 표현하는 0.0과 1.0사이의 10진수를 반환할것이다. 예를 들면, 만약 요소가 100px를 가지는 정사각형 DIV이고 (300,300)에 위치한다면, <span class="code">within(divSquare, 330, 330); overlap('vertical', divSquare);</span>는 0.70을 반환해야만 한다. 이 값이 의미하는 것은 DIV의 아래쪽 경계에서 70%(100px - 30px = 70px)를 표시하는 지점이라는 것이다. 이해하기 가장 쉬운 방법은 다른 사각형의 위-왼쪽 구석처럼 주어진 쌍을 생각하는 것이다. 숫자값은 겹치는 넓이와 높이의 퍼센트값일 것이다. </td>
					</tr>
					<tr id="Position.clone">
						<td>clone(source, target)</td><td>instance</td><td>source: element 객체 또는 아이디, target: element 객체 또는 아이디</td>
						<td class="refDescription">source요소에 대해 똑같이 target요소의 크기를 다시 조정하고 다시 위치를 지정</td>
					</tr>
				</tbody></table>


			<hr>
			<p class="footNote">
				<em>
					1.5.0을 위한 이 문서는 여전히 작업중입니다. 이 문서의 업데이트를 계속 지켜봐주십시오.<br>
					만약 에러를 발견한다면, <a href="mailto:sergio_pereira@msn.com">나에게 알려주십시오.</a> 그러면 가능한 한 빨리 그것을 수정할것입니다.<br>

					한글 번역에 관련된 부분은 <a  href="mailto:fromm0@gmail.com">한국어 번역자</a>으로 알려주십시오.
				</em>
			</p>

		</div>
	
	<div class="animatedBox" id="goN2UAnimatedBox"></div>



<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-66384-1";
urchinTracker();
</script>
<script type="text/javascript" src="http://log.inside.daum.net/dwi_log/js/dwi.js"></script>
<script type="text/javascript" >
	_dwiPID="d-A10-162";
	if(typeof(_dwiCatch) == "function") { _dwiCatch();}
</script>
</body></html>
